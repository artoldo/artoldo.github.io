<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Sacrisoft VITUREMA Studio™ – Video Tube Remix Machine</title>
<script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <script src="https://player.vimeo.com/api/player.js"></script>
<style>
/* ---------- Theme ---------- */
:root{
  --panel: rgba(255,255,255,.06);
  --drawer: rgba(20,20,20,.98);
  --rainbow: linear-gradient(270deg, red, orange, yellow, green, cyan, blue, violet, red);
}

/* ---------- Base ---------- */
body{
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, sans-serif;
  background:#000; color:#fff; text-align:center; padding:2rem; margin:0; position:relative;
}
small.filehint{ display:block; margin:.1rem auto .6rem; max-width:920px; opacity:.85 }
.muted{ opacity:.8 }
.dot{ display:inline-block; width:10px; height:10px; border-radius:50%; background:#555; margin-left:6px; vertical-align:middle }
.dot.ready{ background:#25d366; box-shadow:0 0 0 2px rgba(37,211,102,.25) }

/* ---------- Inputs ---------- */
input[type="text"]{
  width:92%; max-width:700px; padding:.6rem; font-size:1rem; margin:.35rem 0;
  border:0; border-radius:8px; color:#000;
}
/* URL inputs: dashed focus */
#audioUrl, #videoUrl, #overlayUrl{
  background:#fff; color:#000; border:2px solid transparent; border-radius:8px;
  transition: border-color .15s ease, background-color .15s ease, color .15s ease;
}
#audioUrl:focus, #audioUrl:active,
#videoUrl:focus, #videoUrl:active,
#overlayUrl:focus, #overlayUrl:active{
  background:transparent; color:#fff; border:2px dashed #fff; outline:none; caret-color:#fff;
}
#audioUrl:focus::placeholder, #videoUrl:focus::placeholder, #overlayUrl:focus::placeholder{ color:rgba(255,255,255,.7) }

/* ---------- Buttons ---------- */
button{
  padding:.6rem 1.1rem; font-size:1rem; margin:.35rem; cursor:pointer;
  background:#444; color:#fff; border:0; border-radius:8px;
}
button:hover{ background:#666 }
button:disabled{ opacity:.5; cursor:not-allowed }

/* Remix (Build) button – rainbow, normal caps */
#buildBtn{
  font-size:1.0em; font-weight:bold; color:#fff;
  background:var(--rainbow); background-size:400% 400%;
  animation:rainbowFlow 6s ease infinite;
  transition:transform .2s ease;
  box-shadow:none;
  text-transform:none;
  letter-spacing:normal;
}
#buildBtn:hover{ transform:scale(1.05) }
#buildBtn:active{ transform:scale(0.98) }

/* ---------- Panels ---------- */
#progressContainer, #volumeContainer, #presetControls{
  width:92%; max-width:920px; margin:1rem auto; text-align:center; background:var(--panel); padding:1rem; border-radius:12px;
}
#presetControls{ text-align:center }
.panel{ background:var(--panel); padding:1rem; border-radius:12px; width:92%; max-width:920px; margin:1rem auto }

/* ---------- Hidden media elements ---------- */
#playerAudio, #playerVideo{ position:absolute; width:1px; height:1px; opacity:0; pointer-events:none }

/* ---------- Background video/overlay ---------- */
#backgroundVideoContainer{ position:fixed; inset:0; z-index:-2; background:#000; overflow:hidden }
video.bg, iframe.bg{
  position:absolute; inset:0; width:100vw; height:100vh; object-fit:cover; pointer-events:none;
  transition:filter .25s ease, opacity .25s ease;
}
video.overlay, iframe.overlay{ mix-blend-mode:screen; z-index:5 }
body::before{ content:""; position:fixed; inset:0; background:rgba(0,0,0,.5); z-index:-1 }

/* ---------- Preset Drawer ---------- */
#presetOverlay{ position:fixed; inset:0; background:rgba(0,0,0,.5); z-index:9998; opacity:0; pointer-events:none; transition:opacity .25s }
#presetDrawer{
  position:fixed; left:0; right:0; bottom:0; background:var(--drawer); color:#eee;
  border-top-left-radius:16px; border-top-right-radius:16px; box-shadow:0 -10px 30px rgba(0,0,0,.6);
  z-index:9999; transform:translateY(100%); transition:transform .3s; padding:1rem;
}
#presetOverlay.active{ opacity:1; pointer-events:auto }  #presetDrawer.active{ transform:translateY(0%) }
.drawer-header{ display:flex; align-items:center; justify-content:space-between; max-width:1000px; margin:.25rem auto .5rem }
.drawer-title{ font-weight:600 }
.drawer-body{ max-width:1000px; margin:0 auto; text-align:left }

/* ---------- Restore Modal ---------- */
#restoreOverlay{ position:fixed; inset:0; background:rgba(0,0,0,.6); opacity:0; pointer-events:none; transition:opacity .25s; z-index:10000 }
#restoreModal{
  position:fixed; left:50%; top:50%; transform:translate(-50%,-50%);
  width:min(680px,92vw); background:#161616; color:#eee; border-radius:14px;
  box-shadow:0 18px 50px rgba(0,0,0,.5); padding:1rem 1.25rem; z-index:10001; opacity:0; pointer-events:none; transition:opacity .25s;
}
#restoreOverlay.active, #restoreModal.active{ opacity:1; pointer-events:auto }
.restore-row{
  display:flex; align-items:center; justify-content:space-between; background:rgba(255,255,255,.06);
  padding:.6rem .75rem; border-radius:10px; margin:.35rem 0;
}
.ok{ color:#7CFC8A } .warn{ color:#f7d774 }

/* ---------- Items Viewer ---------- */
#itemsOverlay{ position:fixed; inset:0; background:rgba(0,0,0,.6); opacity:0; pointer-events:none; transition:opacity .25s; z-index:10010 }
#itemsModal{
  position:fixed; left:50%; top:50%; transform:translate(-50%,-50%);
  width:min(980px,96vw); max-height:84vh; overflow:auto; background:#111; color:#eee;
  border-radius:14px; box-shadow:0 18px 50px rgba(0,0,0,.5); padding:1rem; z-index:10011; opacity:0; pointer-events:none; transition:opacity .25s;
}
#itemsOverlay.active, #itemsModal.active{ opacity:1; pointer-events:auto }
.itemsGrid{ display:grid; grid-template-columns:1fr 1fr; gap:1rem }
.section{ background:#171717; border-radius:12px; padding:.75rem }
.section h4{ margin:.25rem 0 .5rem; opacity:.85; text-align:center }
.ytGrid{ display:grid; grid-template-columns:repeat(auto-fill,minmax(140px,1fr)); gap:.6rem }
.ytThumb{ background:#1a1a1a; border-radius:10px; overflow:hidden; cursor:pointer }
.ytThumb img{ width:100%; display:block }
.ytThumb .cap{ padding:.35rem .5rem; font-size:.85rem; opacity:.85; text-align:center }
.ytThumb.active{ outline:2px solid #7CFC8A }
.localList{ display:flex; flex-direction:column; gap:.35rem }
.localRow{ display:flex; align-items:center; gap:.5rem; background:#1a1a1a; padding:.4rem .55rem; border-radius:8px; cursor:pointer }
.localRow.active{ outline:2px solid #7CFC8A }
.badge{ font-size:.8rem; opacity:.9; background:#2a2a2a; padding:.05rem .4rem; border-radius:6px }
.index{ width:2.2rem; text-align:right; opacity:.8 }
.name{ flex:1; overflow:hidden; text-overflow:ellipsis; white-space:nowrap }
.cap small{ opacity:.7 }
@media (max-width:800px){ .itemsGrid{ grid-template-columns:1fr } }

/* ---------- Toast ---------- */
#toast{
  position:fixed; left:50%; bottom:24px; transform:translateX(-50%);
  background:rgba(30,30,30,.95); color:#fff; padding:10px 16px; border-radius:8px; font-size:.95rem;
  box-shadow:0 8px 24px rgba(0,0,0,.35); opacity:0; pointer-events:none; transition:opacity .25s; z-index:11000;
}
#toast.show{ opacity:1 }

/* ---------- Record Modal + Convert Bar ---------- */
#recModalOverlay{ position:fixed; inset:0; background:rgba(0,0,0,.5); z-index:11001; opacity:0; pointer-events:none; transition:opacity .25s }
#recModal{
  position:fixed; left:50%; top:50%; transform:translate(-50%,-50%);
  width:min(680px,92vw); background:#161616; color:#eee; border-radius:14px;
  box-shadow:0 18px 50px rgba(0,0,0,.5); padding:1rem; z-index:11002; opacity:0; pointer-events:none; transition:opacity .25s;
}
#recModalOverlay.active, #recModal.active{ opacity:1; pointer-events:auto }
#convertBar{
  position:fixed; left:50%; bottom:12px; transform:translateX(-50%);
  width:min(520px,92vw); background:rgba(25,25,25,.96);
  border:1px solid rgba(255,255,255,.08); border-radius:10px;
  box-shadow:0 8px 24px rgba(0,0,0,.35); z-index:11003; padding:.6rem .8rem; display:none;
}
#convertBar .track{ width:100%; height:10px; background:rgba(255,255,255,.1); border-radius:8px; overflow:hidden }
#convertBar .bar{ height:100%; width:0; background:#4aa3ff }
#recordBtn.recording{ background:#b00020; animation:pulse 1.2s ease-in-out infinite }
@keyframes pulse{0%{box-shadow:0 0 0 0 rgba(176,0,32,.6)}70%{box-shadow:0 0 0 12px rgba(176,0,32,0)}100%{box-shadow:0 0 0 0 rgba(176,0,32,0)}}
label.inline{ margin-left:.25rem; font-size:.95rem; vertical-align:middle }
#recordBadge{ margin-left:.35rem; vertical-align:middle }

/* ---------- Filters spacing ---------- */
.panel label{ display:block; text-align:left; margin:.4rem 0 .25rem }
.panel input[type="range"]{ margin:0 0 .75rem }

/* ---------- Sliders (white thumb, animated rainbow fill) ---------- */
input[type="range"]{
  --p: 0%;
  appearance:none; width:100%; height:10px; border-radius:999px; outline:none;
  background: var(--rainbow) 0 / var(--p) 100% no-repeat, rgba(255,255,255,.18);
  background-size:400% 400%, auto;
  animation:rainbowFlow 6s ease infinite;
}
input[type="range"]:disabled{ opacity:.5 }
input[type="range"]::-webkit-slider-runnable-track{
  height:10px; background:transparent; border-radius:999px;
}
input[type="range"]::-webkit-slider-thumb{
  -webkit-appearance:none; width:16px; height:16px; border-radius:50%;
  background:#fff; border:0; margin-top:-3px; cursor:pointer;
}
input[type="range"]::-moz-range-track{
  height:10px; background:rgba(255,255,255,.18); border:0; border-radius:999px;
}
input[type="range"]::-moz-range-progress{
  height:10px; background:var(--rainbow); background-size:400% 400%;
  border-radius:999px; animation:rainbowFlow 6s ease infinite;
}
input[type="range"]::-moz-range-thumb{
  width:16px; height:16px; border-radius:50%; background:#fff; border:0; cursor:pointer;
}

/* ---------- Shared keyframes ---------- */
@keyframes rainbowFlow{
  0%{   background-position:0% 50% }
  50%{  background-position:100% 50% }
  100%{ background-position:0% 50% }
}

/* --- Preset Manager: merged (tighter input + left-aligned details) --- */
#presetDrawer .preset-row{
  display:grid;
  /* compact input + three buttons */
  grid-template-columns: clamp(280px, 36vw, 420px) auto auto auto;
  gap:12px;
  align-items:center;
  background:rgba(255,255,255,.05);
  padding:.5rem .75rem;
  border-radius:10px;
  margin:.35rem 0;
}
#presetDrawer .preset-row > :first-child{
  padding-right:8px;
  display:flex;
  align-items:center;
}
#presetDrawer .preset-row input[type="text"]{
  width:100%;
  max-width:none;                 /* capped by the grid column above */
  margin:0;
  padding:.45rem .6rem;
  border-radius:8px;
  border:0;
  box-sizing:border-box;
}
#presetDrawer .preset-row button{ margin:0; }
#presetDrawer .preset-row .details{
  grid-column:1 / -1;
  margin-top:.45rem;
  text-align:left;
  display:flex;
  flex-direction:column;
  gap:.2rem;
  opacity:.9;
  font-size:.9rem;
}
#presetDrawer .preset-row .detail{
  white-space:nowrap;
  overflow:auto;
  -webkit-overflow-scrolling:touch;
}
#presetDrawer .preset-row .detail .label{
  font-weight:700;
  margin-right:.35rem;
}

/* Save Current row: compact input + one button */
#presetDrawer .preset-row:has(#createPresetBtn){
  grid-template-columns: clamp(280px, 36vw, 420px) auto;
}

/* Drawer inputs focus (match URL inputs) */
#presetDrawer input[type="text"]:focus,
#presetDrawer input[type="text"]:active{
  background:transparent;
  color:#fff;
  border:2px dashed #fff;
  outline:none;
  caret-color:#fff;
  box-shadow:none !important;
}
#presetDrawer input[type="text"]:focus::placeholder{
  color:rgba(255,255,255,.7);
}

/* Danger button variant (scoped) */
#presetDrawer .preset-row .danger{ background:#444 }
#presetDrawer .preset-row .danger:hover{ background: red}

/* Small screens: stack if space is tight */
@media (max-width:740px){
  #presetDrawer .preset-row{ grid-template-columns:1fr; row-gap:.5rem; }
  #presetDrawer .preset-row:has(#createPresetBtn){ grid-template-columns:1fr; }
  #presetDrawer .preset-row input[type="text"]{ max-width:100%; }
}

/* Save Current row: input (compact) + compact button (no stretch) */
#presetDrawer .preset-row:has(#createPresetBtn){
  grid-template-columns: clamp(280px, 36vw, 420px) max-content; /* button track = content width */
  gap: 12px;
}

/* Make the Save Current button smaller and keep it tight to the input */
#presetDrawer .preset-row:has(#createPresetBtn) #createPresetBtn{
  white-space: nowrap;
  width: auto;                /* ensure no inherited width */
  justify-self: start;        /* prevent grid stretch */
}

/* Record resolution selector */
#presetControls #recResWrap{
  display:inline-flex;
  align-items:center;
  gap:.45rem;
  margin-left:.5rem;
}

#presetControls select#recRes{
  appearance:none;             /* also works on Safari */
  -webkit-appearance:none;
  box-sizing:border-box;
  padding:.45rem .75rem;
  border-radius:8px;
  border:2px solid transparent;   /* same in normal + focus to avoid layout/AA shifts */
  background:var(--panel);         /* keep the same bg on focus */
  color:#fff;
  font-family:inherit;
  font-size:1rem;
  line-height:1.2;
  font-weight:600;
  cursor:pointer;

  /* keep text rendering steady on WebKit */
  -webkit-font-smoothing: antialiased;
  text-rendering: optimizeLegibility;
}

/* Focus: add an outline instead of changing border/background */
#presetControls select#recRes:focus{
  outline:2px dashed #fff;
}

/* Disabled during recording */
#presetControls select#recRes:disabled{
  opacity:.6;
  cursor:not-allowed;
}


/* Mic on = orange */
button.recording {
  background-color: orange;
  color: white;
}

/* Webcam on = green */
button.cam-active {
  background-color: lime;
  color: white;
}

</style>
</head>
<body>
  <div class="muted" style="max-width:900px;margin:0 auto .5rem;">
  <img src="./images/icon.png" width="100px">
  <br>Sacrisoft
  </div>
  <h1>VITUREMA Studio™</h1>
  <h2>Video Tube Remix Machine</h2>

  <!-- AUDIO (optional) -->
  <div>
    <label>AUDIO Playlist</label>
    <button id="pickAudioBtn">Add Local File(s)</button>
    <button id="micRecBtn" aria-pressed="false">Mic</button>
    <input type="text" id="audioUrl" placeholder="OR paste YouTube single/playlist OR direct URL .mp3/.m4a/.ogg/.wav (optional)">
    <span id="audioDot" class="dot" aria-label="audio not ready"></span>
    <button id="viewAudioItemsBtn" title="">View Item(s)</button>
    <input id="audioFiles" type="file" accept="audio/*" multiple style="display:none">
    <small id="audioHint" class="filehint"></small>
  </div>

  <!-- PRIMARY VIDEO (required for visuals) -->
  <div>
    <label>VIDEO Primary</label>
    <button id="pickPrimaryBtn">Add Local File(s)</button>
    <button id="primaryCamBtn" title="" aria-pressed="false">Webcam</button>
    <input type="text" id="videoUrl" placeholder="OR paste YouTube single/playlist OR direct URL .mp4/.webm OR HLS .m3u8">
    <span id="videoDot" class="dot" aria-label="video not ready"></span>
    <button id="viewVideoItemsBtn" title="">View Item(s)</button>
    <input id="primaryFiles" type="file" accept="video/*" multiple style="display:none">
    <small id="videoHint" class="filehint"></small>
  </div>

  <!-- OVERLAY VIDEO (optional) -->
  <div>
    <label>VIDEO Overlay</label>
    <button id="pickOverlayBtn">Add Local File(s)</button>
    <button id="overlayCamBtn" title="" aria-pressed="false">Webcam</button>
    <input type="text" id="overlayUrl" placeholder="OR paste YouTube single/playlist OR direct URL .mp4/.webm OR HLS .m3u8 (optional)">
    <span id="overlayDot" class="dot" aria-label="overlay not ready"></span>
    <button id="viewOverlayItemsBtn" title="">View Item(s)</button>
    <input id="overlayFiles" type="file" accept="video/*" multiple style="display:none">
    <small id="overlayHint" class="filehint"></small>
  </div>

  <div id="controls">
    <button id="buildBtn" class="start">Remix</button>
    <button id="managePresetsBtn">Presets</button>
    <button id="resetBtn" class="reset">Reset</button>
    <button id="playPauseMusicBtn" disabled>Play Audio</button>
    <button id="shuffleMusicBtn" disabled>Shuffle</button>
    <button id="prevBtn" disabled>Previous</button>
    <button id="nextBtn" disabled>Next</button>
    <button id="loopBtn" disabled>Loop Audio: Off</button>
    <button id="playVisualsBtn" disabled>Play Video</button>
    <button id="shuffleVideoBtn" disabled>Shuffle</button>
    <button id="fullscreenBtn">Fullscreen</button>
    <button id="streamBtn">Stream</button>
  </div>

  <div id="presetControls">
    <h2>Output</h2>
    <select id="recRes">
    <option value="1280x720">720p</option>
    <option value="1920x1080" selected>1080p</option>
    <option value="3840x2160">4K</option>
    </select>
    <label class="inline" id="recResWrap" style="margin-left:.5rem;"></label>
    <button id="recordBtn" title=""  
    style="background-color:red;" disabled>Record Remix
    </button>
    <span id="recordBadge" class="badge">Waiting...</span>
  </div>

  <div id="progressContainer">
    <h2>Audio</h2>
    <div>Progress</div>
    <input type="range" id="seekbar" min="0" max="100" value="0">
  </div>

  <div id="volumeContainer">
    <label for="volume">Volume</label>
    <input type="range" id="volume" min="0" max="100" value="100">
  </div>

  <div id="songTitle">Title: -</div>

  <div class="panel">
    <h2>Video Filters</h2>
    <label for="filterBlur">Blur</label>
    <input type="range" id="filterBlur" min="0" max="10" step="0.5" value="0">
    <label for="filterGrayscale">Grayscale</label>
    <input type="range" id="filterGrayscale" min="0" max="100" step="10" value="0">
    <label for="filterBrightness">Brightness</label>
    <input type="range" id="filterBrightness" min="50" max="150" step="10" value="100">
    <label for="filterContrast">Contrast</label>
    <input type="range" id="filterContrast" min="50" max="150" step="10" value="100">
    <label for="filterSepia">Sepia</label>
    <input type="range" id="filterSepia" min="0" max="100" step="10" value="0">
    <label for="filterSaturate">Saturate</label>
    <input type="range" id="filterSaturate" min="0" max="200" step="10" value="100">
    <label for="filterInvert">Invert</label>
    <input type="range" id="filterInvert" min="0" max="100" step="1" value="0">
    <label for="filterHueRotate">Hue Rotate</label>
    <input type="range" id="filterHueRotate" min="0" max="360" step="1" value="0">
    <label for="overlayOpacity">Overlay Opacity</label>
    <input type="range" id="overlayOpacity" min="0" max="100" step="1" value="50">
  </div>

  <div id="playerAudio"></div>
  <div id="playerVideo"></div>
  <div id="backgroundVideoContainer"></div>

  <!-- Preset Drawer -->
  <div id="presetOverlay"></div>
  <div id="presetDrawer" role="dialog" aria-modal="true" aria-label="Preset Manager">
    <div class="drawer-header">
      <div class="drawer-title">Preset Manager</div>
      <div><button id="closePresetDrawerBtn">Close</button></div>
    </div>
    <div class="drawer-body">
      <div id="presetList"></div>
      <div class="preset-row">
        <input type="text" id="newPresetName" placeholder="New preset name">
        <button id="createPresetBtn">Save Current</button>
        <span></span><span></span>
      </div>
    </div>
  </div>

  <!-- Restore Local Modal -->
  <div id="restoreOverlay"></div>
  <div id="restoreModal" role="dialog" aria-modal="true" aria-label="Restore Local Files">
    <h3>Restore local files for this preset</h3>
    <div class="muted">Select files from your computer. We'll match by filename.</div>
    <div id="restoreSummary"></div>
    <div class="restore-row">
      <div><b>Audio</b> — <span id="restoreAudioStatus" class="muted">0 matched</span></div>
      <div>
        <button id="restorePickAudioBtn">Choose audio files</button>
        <input id="restoreAudioFiles" type="file" accept="audio/*" multiple style="display:none">
      </div>
    </div>
    <div class="restore-row">
      <div><b>Primary</b> — <span id="restorePrimaryStatus" class="muted">0 matched</span></div>
      <div>
        <button id="restorePickPrimaryBtn">Choose primary videos</button>
        <input id="restorePrimaryFiles" type="file" accept="video/*" multiple style="display:none">
      </div>
    </div>
    <div class="restore-row">
      <div><b>Overlay</b> — <span id="restoreOverlayStatus" class="muted">0 matched</span></div>
      <div>
        <button id="restorePickOverlayBtn">Choose overlay videos</button>
        <input id="restoreOverlayFiles" type="file" accept="video/*" multiple style="display:none">
      </div>
    </div>
    <div class="modal-actions" style="text-align:right;margin-top:.5rem">
      <button id="restoreCancelBtn">Cancel</button>
      <button id="restoreApplyBtn">Done & Build</button>
    </div>
  </div>

  <!-- Items viewer modal -->
  <div id="itemsOverlay"></div>
  <div id="itemsModal" role="dialog" aria-modal="true" aria-label="Items">
    <div style="display:flex;justify-content:space-between;align-items:center;gap:.5rem">
      <h3 style="margin:.25rem 0">Items</h3>
      <div><button id="closeItemsBtn">Close</button></div>
    </div>
    <div id="itemsInfo" class="muted" style="margin-bottom:.5rem"></div>
    <div class="itemsGrid">
      <div class="section">
        <h4>Local items</h4>
        <div id="localList" class="localList"></div>
      </div>
      <div class="section">
        <h4>YouTube playlist</h4>
        <div id="ytItems" class="ytGrid"></div>
      </div>
    </div>
  </div>

  <!-- Record Modal + Convert Bar -->
  <div id="recModalOverlay"></div>
  <div id="recModal" role="dialog" aria-modal="true" aria-label="Save Recording">
    <div style="display:flex;justify-content:space-between;align-items:center;gap:.5rem">
      <div style="font-weight:600">Save Recording</div>
      <div><button id="recCloseBtn">Close</button></div>
    </div>
    <div style="display:grid;grid-template-columns:1fr auto;gap:.5rem;margin-top:.5rem">
      <input type="text" id="recName" placeholder="remix-YYYYMMDD-HHMMSS.mp4">
      <button id="recSaveBtn">Save</button>
    </div>
  </div>
  <div id="convertBar">
    <div class="label">Converting to MP4… <span id="convertPct">0%</span></div>
    <div class="track"><div class="bar" id="convertBarFill"></div></div>
  </div>

  <div id="toast"></div>

  <div class="muted" style="max-width:900px;margin:0 auto .5rem;">
  <img src="./images/logo.png" width="100px">
  <br>© <span id="copyYear" data-start="2025"></span> Sacrisoft
  <br>All rights reserved.
  </div>

  <script>

function updateCopyrightYear(){
  const el = $('copyYear');
  if (!el) return;
  const now = new Date().getFullYear();
  const start = parseInt(el.dataset.start, 10);
  el.textContent = (start && start < now) ? `${start}–${now}` : `${now}`;
}
document.addEventListener('DOMContentLoaded', updateCopyrightYear);

    /* ========== YouTube API readiness ========== */
    let ytReadyResolve;
    const whenYTReady = new Promise(r=>{ ytReadyResolve=r; });
    window.onYouTubeIframeAPIReady = () => ytReadyResolve();
    (function(){ const s=document.createElement('script'); s.src='https://www.youtube.com/iframe_api'; document.body.appendChild(s); })();

    /* ========== Utilities ========== */
    const $ = id => document.getElementById(id);
    const setDot = (el, ok)=>{ el.classList.toggle('ready', !!ok); el.setAttribute('aria-label', ok?'ready':'not ready'); };
    const toast = (m='', d=4000)=>{ const t=$('toast'); t.textContent=m; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'), d); };

    function extractVideoId(url){
      if(!url) return null;
      const pats=[/youtu\.be\/([0-9A-Za-z_-]{11})/, /v=([0-9A-Za-z_-]{11})/, /\/shorts\/([0-9A-Za-z_-]{11})/, /\/embed\/([0-9A-Za-z_-]{11})/, /\/([0-9A-Za-z_-]{11})(?:\?|&|$)/];
      for(const p of pats){ const m=url.match(p); if(m) return m[1]; }
      return null;
    }
    function extractPlaylistId(url){ const m=(url||'').match(/[?&]list=([a-zA-Z0-9_-]+)/); return m?m[1]:null; }
    const isPlaylist = url => !!(url && url.includes('list='));

    

    // Vimeo supports:
    // - https://vimeo.com/769844428
    // - https://player.vimeo.com/video/769844428
    // - Unlisted:
    //    • https://vimeo.com/769844428/h1a2b3c4d5
    //    • https://player.vimeo.com/video/769844428?h=1a2b3c4d5
    function extractVimeoInfo(url){
      if(!url) return { id:null, h:null };
      let id=null, h=null;

      // Best-effort URL parse (handles query params cleanly)
      try{
        const normalized = (/^https?:\/\//i.test(url) ? url : ('https://' + url.replace(/^\/\//,'')));
        const u = new URL(normalized);

        // ID can appear in pathname as /video/<id> or /<id>
        const m1 = u.pathname.match(/\/(?:video\/)?(\d+)(?:\/([A-Za-z0-9]+))?\/?$/);
        if(m1){
          id = m1[1] || null;
          if(m1[2]) h = m1[2];
        }

        // Unlisted hash sometimes provided as query param
        const qh = u.searchParams.get('h');
        if(qh) h = qh;
      }catch(e){
        // Fallback regex if URL() fails (e.g. missing scheme)
        const m = (url||'').match(/vimeo\.com\/(?:video\/)?(\d+)(?:\/([A-Za-z0-9]+))?/i);
        if(m){ id = m[1] || null; h = m[2] || null; }
        const q = (url||'').match(/[?&]h=([A-Za-z0-9]+)/i);
        if(q) h = q[1];
      }

      return { id, h };
    }
function classify(url){
      if(!url) return null;
      const u = url.split('#')[0];
      const s = u.toLowerCase();
      if(s.includes('youtube.com')||s.includes('youtu.be')) return {kind:'youtube', id:extractVideoId(url), pid:extractPlaylistId(url), isList:isPlaylist(url)};
      if(s.includes('vimeo.com')) {
        const info = extractVimeoInfo(url);
        return {kind:'vimeo', id:info.id, h:info.h};
      }
if(/\.m3u8(\?|$)/i.test(s)) return {kind:'hls'};
      if(/\.(mp4|webm|mov|mkv)(\?|$)/i.test(s)) return {kind:'file'};
      if (/\.(mp3|m4a|aac|flac|wav|ogg|opus)(\?|$)/i.test(s)) return {kind:'audio'};
      return {kind:'unknown'};
    }

    /* ========== State ========== */
    let audioPlayer=null;         // YT audio
    let localAudioEl=null;        // <audio> for local or direct audio
    let localAudioList=[]; let localAudioIdx=0;
    let localPrimaryEl=null; let localPrimaryList=[]; let localPrimaryIdx=0;
    let localOverlayEl=null; let localOverlayList=[]; let localOverlayIdx=0;
    let primaryYTPlayer=null; let overlayYTPlayer=null;
    let primaryVimeoPlayer=null; let overlayVimeoPlayer=null;
    let primaryVimeoPlaying=false; let overlayVimeoPlaying=false;
    let primaryHls=null; let overlayHls=null;
    let isLooping=false, isPlaying=false, seekInterval=null;
    let currentAudioTitle='-';
    let hasBuiltOnce=false;

    // Recorder state + guard
    let isRecording=false, recCanvas=null, recCtx=null, recRAF=null;
    let mediaRecorder=null, recordedChunks=[], canvasStream=null;
    let audioCtx=null, mediaDest=null;
    let ffmpeg=null, ffmpegLoaded=false;
    let recStatus='checking'; // 'ok' | 'checking' | 'no-yt' | 'no-visuals' | 'cors-blocked'

    // Handles (Chrome/Edge) + IndexedDB
    let localAudioHandles=null, localPrimaryHandles=null, localOverlayHandles=null;
    const DB_NAME='remix-presets-db'; const STORE='handles';
    function idbOpen(){ return new Promise((res,rej)=>{ const req=indexedDB.open(DB_NAME,1); req.onupgradeneeded=()=>{ req.result.createObjectStore(STORE); }; req.onsuccess=()=>res(req.result); req.onerror=()=>rej(req.error); }); }
    async function idbSet(key, value){ const db=await idbOpen(); return new Promise((res,rej)=>{ const tx=db.transaction(STORE,'readwrite'); tx.objectStore(STORE).put(value,key); tx.oncomplete=()=>res(); tx.onerror=()=>rej(tx.error); }); }
    async function idbGet(key){ const db=await idbOpen(); return new Promise((res,rej)=>{ const tx=db.transaction(STORE,'readonly'); const req=tx.objectStore(STORE).get(key); req.onsuccess=()=>res(req.result); req.onerror=()=>rej(req.error); }); }
    function uuid(){ return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c=>(c^crypto.getRandomValues(new Uint8Array(1))[0]&15>>c/4).toString(16)); }
    async function ensureRead(handle){ if(!handle) return false; if(handle.queryPermission){ const p = await handle.queryPermission({mode:'read'}); if(p==='granted') return true; } if(handle.requestPermission){ const p = await handle.requestPermission({mode:'read'}); return p==='granted'; } return false; }
    async function handlesToFiles(handles){ const out=[]; for(const h of (handles||[])){ try{ const ok = await ensureRead(h); if(!ok) continue; const f = await h.getFile(); out.push({url:URL.createObjectURL(f), name:f.name}); }catch(e){} } return out; }


/* ========== Webcam sources (Primary & Overlay) ========== */
let primaryCamStream = null;
let overlayCamStream = null;
let primaryCamDeviceId = null;
let overlayCamDeviceId = null;

async function listVideoInputs(){
  try {
    const devices = await navigator.mediaDevices.enumerateDevices();
    return devices.filter(d => d.kind === 'videoinput');
  } catch(_) { return []; }
}

// Try to choose a camera different from the one already used by the other layer.
async function chooseCameraDevice(excludeDeviceId=null){
  const cams = await listVideoInputs();
  if (!cams.length) return null;
  // Prefer a device that isn't excluded
  const alt = cams.find(c => c.deviceId && c.deviceId !== excludeDeviceId);
  return alt ? alt.deviceId : cams[0].deviceId;
}

function makeCamVideoEl(className){
  const v = document.createElement('video');
  v.className = className;
  v.muted = true;        // no echo (your audio comes from the audio player)
  v.autoplay = true;
  v.playsInline = true;
  v.crossOrigin = 'anonymous';
  // Fill viewport like your other sources
  v.style.position = 'absolute';
  v.style.inset = '0';
  v.style.width = '100vw';
  v.style.height = '100vh';
  v.style.objectFit = 'cover';
  v.style.pointerEvents = 'none';
  return v;
}

function stopStream(stream){
  try { stream.getTracks().forEach(t => t.stop()); } catch(_){}
}

function removeIfExists(el){
  if (!el) return;
  try { el.srcObject = null; } catch(_){}
  try { el.remove(); } catch(_){}
}

async function startPrimaryCam(){
  // Pick a device (prefer not the overlay’s one)
  const deviceId = await chooseCameraDevice(overlayCamDeviceId);
  const constraints = deviceId ? { video: { deviceId }, audio: false } : { video: true, audio: false };

  try{
    const stream = await navigator.mediaDevices.getUserMedia(constraints);
    // Clean up any existing primary visuals first
    const c = $('backgroundVideoContainer');
    // If primary is currently a YT/HLS/local player, clear those (primary side)
    if (primaryYTPlayer) { try{ primaryYTPlayer.destroy(); }catch(_){ } primaryYTPlayer = null; }
    if (primaryHls) { try{ primaryHls.destroy(); }catch(_){ } primaryHls = null; }
    removeIfExists(window.localPrimaryEl);
    removeIfExists(window.localPrimaryEl2);

    // Build the cam <video>
    const v = makeCamVideoEl('bg');
    v.srcObject = stream;
    c.appendChild(v);
    window.localPrimaryEl = v;     // keep your recorder/play toggles happy
    window.localPrimaryEl2 = null; // dual-buffer not needed for live cam
    primaryCamStream = stream;
    primaryCamDeviceId = deviceId || null;

    // UI polish
    setDot($('videoDot'), true);
    applyFilters();
    updatePlayVisualsLabel();
    evaluateRecordabilityOnce(2500, 120);
    toast('Primary webcam active');
  }catch(err){
    console.error(err);
    toast('Could not access primary webcam');
  }
}

function stopPrimaryCam(){
  stopStream(primaryCamStream);
  primaryCamStream = null;
  primaryCamDeviceId = null;
  removeIfExists(window.localPrimaryEl);
  window.localPrimaryEl = null;
  // Dot reflects only if another primary source isn’t set
  setDot($('videoDot'), localPrimaryList.length>0 || !!$('videoUrl').value.trim());
  evaluateRecordabilityOnce(1500, 120);
  toast('Primary webcam stopped');
}

async function startOverlayCam(){
  const deviceId = await chooseCameraDevice(primaryCamDeviceId);
  const constraints = deviceId ? { video: { deviceId }, audio: false } : { video: true, audio: false };

  try{
    const stream = await navigator.mediaDevices.getUserMedia(constraints);
    const c = $('backgroundVideoContainer');
    // Clear overlay players
    if (overlayYTPlayer) { try{ overlayYTPlayer.destroy(); }catch(_){ } overlayYTPlayer = null; }
    if (overlayHls) { try{ overlayHls.destroy(); }catch(_){ } overlayHls = null; }
    removeIfExists(window.localOverlayEl);
    removeIfExists(window.localOverlayEl2);

    const v = makeCamVideoEl('bg overlay');
    v.style.mixBlendMode = 'screen';   // match your overlay blend
    v.srcObject = stream;
    c.appendChild(v);
    window.localOverlayEl = v;
    window.localOverlayEl2 = null;
    overlayCamStream = stream;
    overlayCamDeviceId = deviceId || null;

    // Respect existing overlay opacity slider
    const op = $('overlayOpacity')?.value || 50;
    v.style.opacity = op/100;

    setDot($('overlayDot'), true);
    applyFilters();
    updatePlayVisualsLabel();
    evaluateRecordabilityOnce(2500, 120);
    toast('Overlay webcam active');
  }catch(err){
    console.error(err);
    toast('Could not access overlay webcam');
  }
}

function stopOverlayCam(){
  stopStream(overlayCamStream);
  overlayCamStream = null;
  overlayCamDeviceId = null;
  removeIfExists(window.localOverlayEl);
  window.localOverlayEl = null;
  setDot($('overlayDot'), localOverlayList.length>0 || !!$('overlayUrl').value.trim());
  evaluateRecordabilityOnce(1500, 120);
  toast('Overlay webcam stopped');
}

/* Bind buttons (toggle behavior) */
$('primaryCamBtn')?.addEventListener('click', async ()=>{
  const btn = $('primaryCamBtn');
  if (primaryCamStream) { 
    stopPrimaryCam(); 
    btn.textContent = 'Webcam'; 
    btn.classList.remove('cam-active'); // remove green
    return; 
  }
  await startPrimaryCam();
  btn.textContent = 'Webcam';
  btn.classList.add('cam-active'); // make green
});

$('overlayCamBtn')?.addEventListener('click', async ()=>{
  const btn = $('overlayCamBtn');
  if (overlayCamStream) { 
    stopOverlayCam(); 
    btn.textContent = 'Webcam'; 
    btn.classList.remove('cam-active'); // remove green
    return; 
  }
  await startOverlayCam();
  btn.textContent = 'Webcam';
  btn.classList.add('cam-active'); // make green
});

/* Keep overlay opacity slider affecting webcam overlay, too */
$('overlayOpacity')?.addEventListener('input', ()=>{
  if (window.localOverlayEl) {
    window.localOverlayEl.style.opacity = ($('overlayOpacity').value || 50)/100;
  }
});

/* --- Auto-rehydrate webcam elements after Remix / container clears --- */
function ensureCamElements(){
  const c = $('backgroundVideoContainer');
  if (!c) return;

  // Primary cam: if stream exists but element is missing, recreate + attach
  if (primaryCamStream) {
    const needPrimary = !window.localPrimaryEl || !document.contains(window.localPrimaryEl);
    if (needPrimary) {
      removeIfExists(window.localPrimaryEl);
      const v = makeCamVideoEl('bg');
      v.srcObject = primaryCamStream;
      c.prepend(v);                 // keep primary behind overlay
      window.localPrimaryEl = v;
      applyFilters?.();
      updatePlayVisualsLabel?.();
    }
  }

  // Overlay cam: same idea, with blend + opacity
  if (overlayCamStream) {
    const needOverlay = !window.localOverlayEl || !document.contains(window.localOverlayEl);
    if (needOverlay) {
      removeIfExists(window.localOverlayEl);
      const v = makeCamVideoEl('bg overlay');
      v.style.mixBlendMode = 'screen';
      v.style.opacity = (($('overlayOpacity')?.value ?? 50) / 100);
      v.style.zIndex = 4;
      v.srcObject = overlayCamStream;
      c.appendChild(v);             // overlay above primary
      window.localOverlayEl = v;
      applyFilters?.();
      updatePlayVisualsLabel?.();
    }
  }
}

/* Watch for Remix-induced DOM changes on the container */
(function initCamRehydration(){
  const container = $('backgroundVideoContainer');
  if (!container) return;
  const mo = new MutationObserver(() => { ensureCamElements(); });
  mo.observe(container, { childList: true });
  // First run in case Remix already happened
  ensureCamElements();
})();

/* Optional: if you have a Remix button, nudge a rehydrate shortly after clicks */
$('remixBtn')?.addEventListener('click', () => {
  // Run twice to catch async rebuilds
  setTimeout(ensureCamElements, 0);
  setTimeout(ensureCamElements, 500);
});



// === Mic toggle (mix mic into the main recording) ===
// keep these at top-level (so other code can read window.micStream/window.micSource)
let micStream = null;
let micSource = null;      // AudioNode, created when we have an AudioContext
let isMicEnabled = false;

async function toggleMic(){
  const b = document.getElementById('micRecBtn');
  if(!isMicEnabled){
    try{
      // get the mic stream
      micStream = await navigator.mediaDevices.getUserMedia({ audio:true, video:false });

      // expose globally for the recorder code which expects window.micStream / micSource
      try{ window.micStream = micStream; }catch(_){}

      // If an AudioContext already exists, create the MediaStreamSource now so it is ready
      try{
        if (window.audioCtx && !window.micSource){
          window.micSource = window.audioCtx.createMediaStreamSource(window.micStream);
        }
      }catch(err){
        console.warn('Could not create micSource at toggle time:', err);
        // keep going — startRecording() will attempt to create it again if needed
      }

      // local copies (if your code reads local vars)
      micSource = window.micSource || null;

      isMicEnabled = true;
      if (b){ b.classList.add('recording'); b.textContent = 'Mic'; b.title = ''; }
    }catch(e){
      console.error('toggleMic getUserMedia error:', e);
      alert('Microphone permission denied or not available.');
      // ensure state is clean
      micStream = null;
      micSource = null;
      try{ window.micStream = null; window.micSource = null; }catch(_){}
      isMicEnabled = false;
      if (b){ b.classList.remove('recording'); b.textContent = 'Mic'; }
    }
  }else{
    // turn mic off: disconnect node and stop tracks
    try{
      if (window.micSource){
        try{ window.micSource.disconnect(); }catch(_){}
      }
      if (micSource){
        try{ micSource.disconnect(); }catch(_){}
      }
    }catch(_){}

    try{ micStream?.getTracks().forEach(t=>t.stop()); }catch(_){}
    micStream = null;
    micSource = null;
    isMicEnabled = false;
    try{ window.micStream = null; window.micSource = null; }catch(_){}
    if (b){ b.classList.remove('recording'); b.textContent = 'Mic'; b.title = ''; }
  }

  // re-run recordability check so Record button updates (debounced)
  try{ queueRecordCheck?.(); }catch(_){}

  // small debug logs — you can remove these after testing
  console.log('toggleMic -> isMicEnabled=', isMicEnabled, 'micStream=', !!window.micStream, 'micSource=', !!window.micSource);
}

// bind (replace any previous binding)
const _micBtn = document.getElementById('micRecBtn');
_micBtn?.removeEventListener?.('click', toggleMic); // harmless if not bound
_micBtn?.addEventListener?.('click', toggleMic);





    /* ========== File pickers (prefer FS Access API) ========== */
    $('pickAudioBtn').addEventListener('click', async ()=>{
      if(window.showOpenFilePicker){
        try{
          const hs = await showOpenFilePicker({multiple:true, types:[{description:'Audio', accept:{'audio/*':['.mp3','.wav','.ogg','.m4a','.flac']}}]});
          const files = await handlesToFiles(hs);
          localAudioList = files; localAudioHandles = hs;
          $('audioHint').textContent = localAudioList.length ? `${localAudioList.length} audio file(s)` : '';
          setDot($('audioDot'), localAudioList.length>0 || !!$('audioUrl').value.trim());
          updateButtons();
      updateStreamButtonState();
          return;
        }catch(e){}
      }
      $('audioFiles').click();
    });
    $('pickPrimaryBtn').addEventListener('click', async ()=>{
      if(window.showOpenFilePicker){
        try{
          const hs = await showOpenFilePicker({multiple:true, types:[{description:'Video', accept:{'video/*':['.mp4','.webm','.mov','.mkv']}}]});
          const files = await handlesToFiles(hs);
          localPrimaryList = files; localPrimaryHandles = hs;
          $('videoHint').textContent = localPrimaryList.length ? `${localPrimaryList.length} primary video(s)` : '';
          setDot($('videoDot'), localPrimaryList.length>0 || !!$('videoUrl').value.trim());
          updateButtons();
      updateStreamButtonState();
          return;
        }catch(e){}
      }
      $('primaryFiles').click();
    });
    $('pickOverlayBtn').addEventListener('click', async ()=>{
      if(window.showOpenFilePicker){
        try{
          const hs = await showOpenFilePicker({multiple:true, types:[{description:'Video', accept:{'video/*':['.mp4','.webm','.mov','.mkv']}}]});
          const files = await handlesToFiles(hs);
          localOverlayList = files; localOverlayHandles = hs;
          $('overlayHint').textContent = localOverlayList.length ? `${localOverlayList.length} overlay video(s)` : '';
          setDot($('overlayDot'), localOverlayList.length>0 || !!$('overlayUrl').value.trim());
          updateButtons();
      updateStreamButtonState();
          return;
        }catch(e){}
      }
      $('overlayFiles').click();
    });

    // fallback <input type=file>
    $('audioFiles').addEventListener('change',e=>{ const files=[...e.target.files||[]]; localAudioList=files.map(f=>({url:URL.createObjectURL(f), name:f.name})); localAudioHandles=null; $('audioHint').textContent=localAudioList.length?`${localAudioList.length} audio file(s)`:''; setDot($('audioDot'), localAudioList.length>0 || !!$('audioUrl').value.trim()); updateButtons(); });
    $('primaryFiles').addEventListener('change',e=>{ const files=[...e.target.files||[]]; localPrimaryList=files.map(f=>({url:URL.createObjectURL(f), name:f.name})); localPrimaryHandles=null; $('videoHint').textContent=localPrimaryList.length?`${localPrimaryList.length} primary video(s)`:''; setDot($('videoDot'), localPrimaryList.length>0 || !!$('videoUrl').value.trim()); updateButtons(); });
    $('overlayFiles').addEventListener('change',e=>{ const files=[...e.target.files||[]]; localOverlayList=files.map(f=>({url:URL.createObjectURL(f), name:f.name})); localOverlayHandles=null; $('overlayHint').textContent=localOverlayList.length?`${localOverlayList.length} overlay video(s)`:''; setDot($('overlayDot'), localOverlayList.length>0 || !!$('overlayUrl').value.trim()); updateButtons(); });

    ['audioUrl','videoUrl','overlayUrl'].forEach(id=>$(id).addEventListener('input',()=>{
      setDot($('audioDot'), localAudioList.length>0 || !!$('audioUrl').value.trim());
      setDot($('videoDot'), localPrimaryList.length>0 || !!$('videoUrl').value.trim());
      setDot($('overlayDot'), localOverlayList.length>0 || !!$('overlayUrl').value.trim());
      updateButtons();
      updateStreamButtonState();
    }));

    function anyAudio(){ return localAudioList.length>0 || !!$('audioUrl').value.trim(); }
    function anyVisual(){ return localPrimaryList.length>0 || !!$('videoUrl').value.trim() || localOverlayList.length>0 || !!$('overlayUrl').value.trim(); }

    function updateButtons(){
      $('playPauseMusicBtn').disabled = !(hasBuiltOnce && anyAudio());
      $('playVisualsBtn').disabled = !(hasBuiltOnce && anyVisual());
      $('shuffleMusicBtn').disabled = !(hasBuiltOnce && anyAudio());
      $('shuffleVideoBtn').disabled = !(hasBuiltOnce && anyVisual());
      $('prevBtn').disabled = !anyAudio();
      $('nextBtn').disabled = !anyAudio();
      $('loopBtn').disabled = !anyAudio();
      updateStreamButtonState();
      queueRecordCheck(); // deferred recordability check
    }

    function updatePlayVisualsLabel(){
      $('playVisualsBtn').textContent = isAnyVideoPlaying()? 'Pause Video' : 'Play Video';
    }


/* ========== Stream availability (disable when YouTube present to avoid error 153) ========== */
function hasYouTubeVisuals(){
  try{
    if (window.primaryYTPlayer || window.overlayYTPlayer || window.audioPlayer) return true;

    const vSpec = classify(($('videoUrl')?.value||'').trim());
    const oSpec = classify(($('overlayUrl')?.value||'').trim());
    const aSpec = classify(($('audioUrl')?.value||'').trim());
    const anySpec = [vSpec,oSpec,aSpec].filter(Boolean);
    if (anySpec.some(s => s.kind==='youtube')) return true;

    const ifrs = document.querySelectorAll('#backgroundVideoContainer iframe');
    for (const ifr of ifrs){
      const src = (ifr.getAttribute('src') || '').toLowerCase();
      if (src.includes('youtube.com') || src.includes('youtube-nocookie.com') || src.includes('youtu.be')) return true;
    }
    return false;
  }catch(_){ return false; }
}
function updateStreamButtonState(){
  const b = document.getElementById('streamBtn');
  if(!b) return;
  const yt = hasYouTubeVisuals();
  b.disabled = !!yt;
  b.title = yt ? 'Stream disabled for YouTube sources (avoids YouTube error 153).' : '';
}

/* ========== Filters ========== */
function applyFilters(){
  const filters = [
    `blur(${$('filterBlur').value}px)`,
    `grayscale(${$('filterGrayscale').value}%)`,
    `brightness(${$('filterBrightness').value}%)`,
    `contrast(${$('filterContrast').value}%)`,
    `sepia(${$('filterSepia').value}%)`,
    `saturate(${$('filterSaturate').value}%)`,
    `invert(${$('filterInvert').value}%)`,
    `hue-rotate(${$('filterHueRotate').value}deg)`
  ].join(' ');
  const op = $('overlayOpacity').value/100;

  const docs = [document];
  if (window.streamWin && !window.streamWin.closed) docs.push(window.streamWin.document);

  docs.forEach(d=>{
    d.querySelectorAll('#backgroundVideoContainer .bg').forEach(el=>{ el.style.filter = filters; });
    d.querySelectorAll('#backgroundVideoContainer .overlay').forEach(el=>{ el.style.opacity = op; });
  });
}

['filterBlur','filterGrayscale','filterBrightness','filterContrast',
 'filterSepia','filterSaturate','filterInvert','filterHueRotate',
 'overlayOpacity']
.forEach(id => $(id)?.addEventListener('input', applyFilters));


function quickEmbedStatusFromInputs(){
      try{
        const a = ($('audioUrl')?.value||'').trim();
        const v = ($('videoUrl')?.value||'').trim();
        const o = ($('overlayUrl')?.value||'').trim();
        const aSpec = classify(a);
        const vSpec = classify(v);
        const oSpec = classify(o);

        const hasEmbed = (aSpec && (aSpec.kind==='youtube' || aSpec.kind==='vimeo')) ||
                         (vSpec && (vSpec.kind==='youtube' || vSpec.kind==='vimeo')) ||
                         (oSpec && (oSpec.kind==='youtube' || oSpec.kind==='vimeo'));

        const hasAnyVisual = !!v || !!o || (localPrimaryList?.length||0)>0 || (localOverlayList?.length||0)>0 || !!primaryCamStream || !!overlayCamStream;
        const hasAnyAudio  = !!a || (localAudioList?.length||0)>0;

        if (hasEmbed){
          setRecordStatus('no-yt');
          return;
        }
        if (!hasAnyVisual && !hasAnyAudio){
          setRecordStatus('no-visuals');
          return;
        }
        setRecordStatus('ok');
      }catch(e){
        try{ setRecordStatus('no-visuals'); }catch(_){}
      }
    }

try{ quickEmbedStatusFromInputs(); }catch(_){ }

// Update Stream availability as URLs change (so it's disabled immediately for YouTube)
['audioUrl','videoUrl','overlayUrl'].forEach(id=>$(id)?.addEventListener('input', ()=>{ try{ quickEmbedStatusFromInputs(); }catch(_){ } try{ updateStreamButtonState(); }catch(_){ } }));
// keep original hook
//
['videoUrl','overlayUrl'].forEach(id => $(id)?.addEventListener('input', updateStreamButtonState));
document.addEventListener('DOMContentLoaded', updateStreamButtonState);


    /* ========== Build / Rebuild ========== */
    $('buildBtn').addEventListener('click', async ()=>{
      const aSpec = classify($('audioUrl').value.trim());
      const vSpec = classify($('videoUrl').value.trim());
      const oSpec = classify($('overlayUrl').value.trim());
      if((aSpec && aSpec.kind==='youtube') || (vSpec && vSpec.kind==='youtube') || (oSpec && oSpec.kind==='youtube')){
        await whenYTReady;
      }
      buildAudio(aSpec);
      buildVisuals(vSpec, oSpec);
      hasBuiltOnce = true;
      updateButtons();
      updateStreamButtonState();
      setTimeout(()=>{ updatePlayVisualsLabel(); $('playVisualsBtn').textContent='Pause Video'; }, 150);
      setTimeout(updatePlayVisualsLabel, 900);
      // evaluate recordability after initial build
      setTimeout(()=>evaluateRecordabilityOnce(2500, 120), 600);
      forceStartAudio(); 
    });

function forceStartAudio(){
  try { audioCtx?.resume?.(); } catch(_) {}
  const a = window.localAudioEl || document.getElementById('htmlAudio');
  if (!a) return;
  a.muted = false; // we want audible playback
  a.play().then(()=>{
    const btn = document.getElementById('playPauseMusicBtn');
    if (btn) btn.textContent = 'Pause Audio';
    startSeek?.();
  }).catch(()=>{/* user can tap Play Audio */});
}

// Stronger: uses a real <audio> in #playerAudio, checks codecs, handles autoplay,
// and supports common formats (mp3/m4a/aac/wav/ogg/opus/flac).
async function loadAudioUrl(url){
  if(!url) return;

  // HLS audio is not supported in <audio>
  if (/\.m3u8(\?|$)/i.test(url)) {
    toast('HLS audio is not supported in <audio>. Put that URL into Video/Overlay instead.');
    return;
  }

  const host = document.getElementById('playerAudio'); // <div id="playerAudio">
  // Ensure we have a persistent <audio> element in the DOM for better iOS/desktop compliance
  if (!host._htmlAudio) {
    const a = document.createElement('audio');
    a.id = 'htmlAudio';
    a.preload = 'auto';
    a.crossOrigin = 'anonymous';
    // visually hidden, but in DOM
    Object.assign(a.style, { position:'absolute', width:'1px', height:'1px', opacity:'0', pointerEvents:'none' });
    host.innerHTML = '';
    host.appendChild(a);
    host._htmlAudio = a;
  }
  window.localAudioEl = host._htmlAudio;

  const a = window.localAudioEl;
  a.loop = !!window.isLooping;            // keep parity with your Loop toggle
  a.volume = (document.getElementById('volume')?.value || 100) / 100;

  // Basic format support check (helps explain Safari/codec mismatches)
  const lc = url.toLowerCase();
  const candidates = [];
  if (/\.mp3(\?|$)/.test(lc))  candidates.push('audio/mpeg');                         // MP3
  if (/\.m4a(\?|$)/.test(lc))  candidates.push('audio/mp4; codecs="mp4a.40.2"');      // M4A (AAC)
  if (/\.aac(\?|$)/.test(lc))  candidates.push('audio/aac');                           // AAC
  if (/\.wav(\?|$)/.test(lc))  candidates.push('audio/wav; codecs="1"');               // WAV (PCM)
  if (/\.ogg(\?|$)/.test(lc))  candidates.push('audio/ogg; codecs="vorbis"');         // OGG (Vorbis)
  if (/\.opus(\?|$)/.test(lc)) candidates.push('audio/ogg; codecs="opus"');           // Opus-in-Ogg
  if (/\.flac(\?|$)/.test(lc)) candidates.push('audio/flac');                          // FLAC (Chrome/FF)

  if (candidates.length && !candidates.some(t => a.canPlayType(t) !== '')) {
    toast('This browser can’t play that audio format. Try MP3/M4A/WAV.');
    return;
  }

  // If a YT audio player exists from a previous build, stop & destroy it
  if (window.audioPlayer && audioPlayer.destroy) {
    try { audioPlayer.stopVideo?.(); audioPlayer.destroy(); } catch(_) {}
    window.audioPlayer = null;
  }

  a.src = url;

  // Helpful state for UI
  document.getElementById('playPauseMusicBtn').disabled = false;
  document.getElementById('playPauseMusicBtn').textContent = 'Play Audio';

  // Try to start on user gesture (the Remix click). If blocked, just enable the button.
  try {
    if (a.readyState >= 2) {
      await a.play();
      document.getElementById('playPauseMusicBtn').textContent = 'Pause Audio';
      startSeek();
    } else {
      await new Promise((resolve, reject)=>{
        a.addEventListener('canplay', resolve, {once:true});
        a.addEventListener('error', ()=>reject(new Error('audio error')), {once:true});
      });
      await a.play();
      document.getElementById('playPauseMusicBtn').textContent = 'Pause Audio';
      startSeek();
    }
  } catch {
    // Autoplay blocked is common — user can tap Play Audio.
    toast('Autoplay blocked. Tap “Play Audio”.');
  }
}

function buildAudio(aSpec){
  // Ensure we have a persistent <audio> element in #playerAudio
  const host = $('playerAudio'); // this is already in your DOM
  if (!host._htmlAudio) {
    const a = document.createElement('audio');
    a.id = 'htmlAudio';
    a.preload = 'auto';
    a.crossOrigin = 'anonymous';
    Object.assign(a.style, { position:'absolute', width:'1px', height:'1px', opacity:'0', pointerEvents:'none' });
    host.innerHTML = '';
    host.appendChild(a);
    host._htmlAudio = a;
  }
  localAudioEl = host._htmlAudio;               // keep your existing variable name in sync
  localAudioEl.volume = (($('volume')?.value) || 100) / 100;

  // If we’re NOT going to use YouTube, stop/destroy any previous YT audio player
  const stopYouTubeAudio = ()=>{
    if (window.audioPlayer && audioPlayer.destroy){
      try { audioPlayer.stopVideo?.(); audioPlayer.destroy(); } catch(_) {}
      window.audioPlayer = null;
    }
  };

  // ========== 1) Local list ==========
  if (localAudioList.length){
    stopYouTubeAudio();

    // attach 'ended' handler once
    if (!localAudioEl._listHandlerAttached){
      localAudioEl.addEventListener('ended', ()=>{
        if(localAudioList.length===1){
          if(isLooping){ localAudioEl.currentTime=0; localAudioEl.play().catch(()=>{}); }
          return;
        }
        if(localAudioIdx < localAudioList.length-1){
          localAudioIdx += 1;
        } else {
          if(isLooping){ localAudioIdx = 0; } else { return; }
        }
        localAudioEl.src = localAudioList[localAudioIdx].url;
        localAudioEl.load(); localAudioEl.play().catch(()=>{});
        updateSongTitle(localAudioList[localAudioIdx].name||'');
        try{ if(itemsModal && itemsModal.classList.contains('active')) showItems('audio'); }catch(e){}
      });
      localAudioEl._listHandlerAttached = true;
    }

    localAudioIdx = 0;
    localAudioEl.loop = false; // playlist handles looping itself
    localAudioEl.src = localAudioList[0].url;
    localAudioEl.load();
    localAudioEl.play?.().catch(()=>{});
    updateSongTitle(localAudioList[0].name||'');
    try{ setDot($('audioDot'), true); }catch(_){}

// ========== 2) Direct audio URL (mp3/m4a/aac/wav/ogg/opus/flac) ==========
} else if (aSpec && aSpec.kind === 'audio') {
  stopYouTubeAudio();
  const url = $('audioUrl').value.trim();
  updateSongTitle(url.split('/').pop());
  // robust loader you added earlier; no need to await here
  loadAudioUrl(url);
  try{ setDot($('audioDot'), !!url); }catch(_){}

  // (3) Autoplay nudge: start audio immediately on this user gesture
  try {
    // resume AudioContext if you use one
    (window.audioCtx && window.audioCtx.resume && window.audioCtx.resume());
    if (window.localAudioEl && window.localAudioEl.paused) {
      window.localAudioEl.play()
        .then(()=>{
          const btn = $('playPauseMusicBtn');
          if (btn) btn.textContent = 'Pause Audio';
          startSeek?.();
        })
        .catch(()=>{ /* if blocked, user can tap Play Audio */ });
    }
  } catch(_) {}

  // ========== 3) YouTube audio (single or playlist) ==========
  } else if (aSpec && aSpec.kind === 'youtube'){
    // Pause/clear the HTML <audio> when using YT audio
    try { localAudioEl.pause?.(); } catch(_){}
    const aId = aSpec.isList ? aSpec.pid : aSpec.id;
    if(!aId){ alert('Invalid audio URL'); updateButtons(); return; }

    if(audioPlayer){
      aSpec.isList ? audioPlayer.loadPlaylist({ list: aId })
                   : audioPlayer.loadVideoById(aId);
    } else {
      audioPlayer = new YT.Player('playerAudio', {
        height:'1', width:'1',
        playerVars: aSpec.isList
          ? { listType:'playlist', list:aId, autoplay:0, controls:0 }
          : { autoplay:0, controls:0, loop:1, playlist:aId },
        events:{
          onReady: onAudioReady,
          onStateChange: (e)=>{
            onAudioStateChange(e);
            if(itemsModal && itemsModal.classList.contains('active') && currentItemsKindOpen==='audio'){
              safeShowItems('audio');
            }
          },
          onError: ()=>alert('YouTube audio error')
        }
      });
    }
    try{ setDot($('audioDot'), true); }catch(_){}

  // ========== 4) Nothing provided ==========
  } else {
    $('songTitle').textContent='Title: -';
    try{ setDot($('audioDot'), false); }catch(_){}
    // also stop YT/HTML audio if nothing selected
    try { localAudioEl.pause?.(); } catch(_){}
    if (window.audioPlayer && audioPlayer.destroy){
      try { audioPlayer.stopVideo?.(); audioPlayer.destroy(); } catch(_) {}
      window.audioPlayer = null;
    }
  }

  updateButtons();
}

    function destroyVisualPlayers(){
      if(primaryYTPlayer){ try{ primaryYTPlayer.destroy(); }catch(e){} primaryYTPlayer=null; }
      if(overlayYTPlayer){ try{ overlayYTPlayer.destroy(); }catch(e){} overlayYTPlayer=null; }
    if(primaryVimeoPlayer){ try{ primaryVimeoPlayer.unload(); }catch(e){} primaryVimeoPlayer=null; primaryVimeoPlaying=false; }
    if(overlayVimeoPlayer){ try{ overlayVimeoPlayer.unload(); }catch(e){} overlayVimeoPlayer=null; overlayVimeoPlaying=false; }
      if(primaryHls){ try{ primaryHls.destroy(); }catch(e){} primaryHls=null; }
      if(overlayHls){ try{ overlayHls.destroy(); }catch(e){} overlayHls=null; }
    }

function attachPlayPauseLabelHandlersFor(el){
  if(!el) return;
  // UI label only — no recordability work during playback
  el.addEventListener('playing', updatePlayVisualsLabel);
  el.addEventListener('pause',   updatePlayVisualsLabel);
}

    function throttle(fn, ms){ let t=0; return ()=>{ const now=Date.now(); if(now-t>ms){ t=now; fn(); } }; }

    function makeVideoEl(className){
      const v = document.createElement('video');
      v.className = className;
      try{ v.style.zIndex = (String(className).includes('overlay') ? '5' : '1'); }catch(_){ }
      v.muted = true; v.autoplay = true; v.playsInline = true;
      v.crossOrigin = 'anonymous'; // allow CORS-enabled drawing for recording
      return v;
    }
function wirePlaylistAdvance(el, listRef, idxRefName, kind){
  // Single item: keep native loop; Multi-item: drive progression on 'ended'.
  el.loop = (listRef.length === 1);

  el.addEventListener('ended', ()=>{
    if (listRef.length > 1){
      // Derive current index from currentSrc (don't depend on window[idxRefName]).
      const srcNow = el.currentSrc || el.src || '';
      let cur = listRef.findIndex(it => it && it.url === srcNow);
      if (cur < 0) cur = 0;
      const nextIdx = (cur + 1) % listRef.length;

      try { el.pause(); } catch(_) {}
      el.src = listRef[nextIdx].url;
      try { el.load(); } catch(_) {}

      const playIt = ()=> el.play().catch(()=>{});
      if (el.readyState >= 2) playIt(); else el.addEventListener('loadeddata', playIt, {once:true});
    } else {
      // One item: seamless loop
      el.currentTime = 0;
      el.play().catch(()=>{});
    }
  });

  // Ensure auto-start whenever a freshly set source becomes ready.
  el.addEventListener('loadeddata', ()=>{
    if (el.paused){ el.play().catch(()=>{}); }
  });
}

// --- Full-cover for <iframe> players (YouTube) just like object-fit:cover ---
function coverIframeToViewport(ifr, ratio = 16/9){
  if(!ifr) return;
  const vw = window.innerWidth, vh = window.innerHeight;
  // compute size that covers viewport at given ratio
  let W = vw, H = W/ratio;
  if (H < vh) { H = vh; W = H*ratio; }
  Object.assign(ifr.style, {
    position: 'absolute',
    left: '50%', top: '50%',
    width: W+'px', height: H+'px',
    transform: 'translate(-50%,-50%)',
    pointerEvents: 'none'
  });
}

// --- Ensure any bg/overlay element fills the viewport (video or YouTube iframe) ---
function ensureCover(el){
  if(!el) return;
  if(el.tagName === 'IFRAME'){ coverIframeToViewport(el, 16/9); return; }
  // <video>
  el.classList.add('bg');
  Object.assign(el.style, {
    position:'absolute', inset:'0',
    width:'100vw', height:'100vh',
    objectFit:'cover', pointerEvents:'none'
  });
}

// --- HLS attach (primary & overlay). Uses native in Safari, hls.js elsewhere ---
function attachHLS(mediaEl, url, {live=false} = {}){
  if(!/\.m3u8(\?|$)/i.test(url)){ return false; } // not HLS -> let normal loader handle it
  // tear down old hls instance if any
  if(mediaEl._hls){ try{ mediaEl._hls.destroy(); }catch(_){} mediaEl._hls = null; }
  if (window.Hls && Hls.isSupported()){
    const h = new Hls({
      lowLatencyMode: live,
      liveDurationInfinity: live,
      enableWorker: true,
      backBufferLength: 60
    });
    h.attachMedia(mediaEl);
    h.on(Hls.Events.MEDIA_ATTACHED, ()=> h.loadSource(url));
    mediaEl._hls = h;
  } else {
    // Safari / native HLS
    mediaEl.src = url;
  }
  mediaEl.crossOrigin = 'anonymous';
  mediaEl.playsInline = true;
  mediaEl.muted = true;            // bg video renders; audio comes from the audio element
  mediaEl.autoplay = true;
  mediaEl.load?.();
  mediaEl.play?.().catch(()=>{});
  return true;
}
    
// Seamless local playback: double-buffer, no fades, no early cut
function buildSeamlessLocal(list, className, kind){
  const c = $('backgroundVideoContainer');

  // two buffers
  const a = document.createElement('video');
  const b = document.createElement('video');
  [a,b].forEach(v=>{
    v.className = className;
    v.muted = true; v.autoplay = true; v.playsInline = true;
    v.crossOrigin = 'anonymous';
    v.preload = 'auto';
    Object.assign(v.style, {
      position:'absolute', inset:'0',
      width:'100vw', height:'100vh',
      objectFit:'cover', pointerEvents:'none',
      zIndex:(className.includes('overlay')?5:1)
    });
    c.appendChild(v);
  });

  let front=a, back=b, idx=0, swapPending=false;

  // preload a source; keep "back" paused at t=0 to avoid jumping ahead
  const setSrc = (target, url, {forFront=false} = {})=>{
    if(!url || !target) return;

    // HLS (rare for "local", but supported)
    if (target._hls){ try{ target._hls.destroy(); }catch(_){} target._hls = null; }
    const isHls = /\.m3u8(\?|$)/i.test(url);
    if (isHls){
      const live = /\/live\//i.test(url) || /live/i.test(url);
      // reuse your helper
      attachHLS(target, url, { live });
    } else {
      target.src = url;
      target.load?.();
    }

    ensureCover(target);

    // keep back buffer ready at the first frame
    if (!forFront){
      target.addEventListener('canplay', ()=>{
        try{ target.pause(); target.currentTime = 0; }catch(_){}
      }, { once:true });
    }
  };

  const nextIdx = () => (idx+1) % list.length;
  const setGlobalIdx = ()=>{
    try{
      if(kind==='video'){ window.localPrimaryIdx = idx; }
      else if(kind==='overlay'){ window.localOverlayIdx = idx; }
    }catch(_){}
  };

  // prime
  setSrc(front, list[0].url, {forFront:true});
  front.style.zIndex = 2;
  if(list.length > 1){ setSrc(back, list[1].url); } else { front.loop = true; }

  // expose the visible element so recorder/UI use the right one
  try{
    if (kind === 'video') {
      window.localPrimaryEl  = front;
      window.localPrimaryEl2 = back;
    } else if (kind === 'overlay') {
      window.localOverlayEl  = front;
      window.localOverlayEl2 = back;
    }
  }catch(_){}

  // instant swap (no opacity change)
  function doSwap(){
    // ensure the new front starts from the first frame
    try{ if(back.currentTime > 0.001) back.currentTime = 0; }catch(_){}
    try{ back.play().catch(()=>{}); }catch(_){}

    front.style.zIndex = 1;
    back.style.zIndex  = 2;

    const oldFront = front; front = back; back = oldFront;

    try{
      if (kind === 'video') {
        window.localPrimaryEl  = front;
        window.localPrimaryEl2 = back;
      } else if (kind === 'overlay') {
        window.localOverlayEl  = front;
        window.localOverlayEl2 = back;
      }
    }catch(_){}

    idx = nextIdx(); setGlobalIdx();
    const preloadIdx = (idx + 1) % list.length;
    setSrc(back, list[preloadIdx].url);   // stays paused at 0 until next swap

    swapPending = false;
    refreshItemsIfOpen(kind);
  }

  // one item: just loop
  if(list.length === 1){
    front.addEventListener('playing', ()=>{ setGlobalIdx(); refreshItemsIfOpen(kind); });
    front.play().catch(()=>{});
    return { el: front, el2: back, getIndex: ()=>idx };
  }

  // swap only when the current video truly ends (no early cut)
  function onEnded(e){
    if(e.target !== front || swapPending) return;
    swapPending = true;

    const go = ()=> doSwap();
    if (back.readyState >= 2) go();
    else back.addEventListener('canplay', go, { once:true });
  }
  front.addEventListener('ended', onEnded);
  back.addEventListener('ended', onEnded);

  // keep UI in sync
  [a,b].forEach(v=>{
    v.addEventListener('playing', ()=>{ setGlobalIdx(); refreshItemsIfOpen(kind); });
  });

  // kick off
  front.addEventListener('loadeddata', ()=>{ if(front.paused){ front.play().catch(()=>{}); } });
  try{ front.play().catch(()=>{}); }catch(_){}

  // overlay blend on both buffers
  if (className.includes('overlay')){
    a.style.mixBlendMode = 'screen';
    b.style.mixBlendMode = 'screen';
  }

  return { el: front, el2: back, getIndex: ()=>idx };
}

function attachHls(el, url, which){
      if(el.canPlayType('application/vnd.apple.mpegurl')){
        el.src = url;
      } else if(window.Hls && Hls.isSupported()){
        const h = new Hls();
        h.loadSource(url); h.attachMedia(el);
        if(which==='primary') primaryHls=h; else overlayHls=h;
        h.on(Hls.Events.MANIFEST_PARSED, evaluateRecordability);
        h.on(Hls.Events.LEVEL_LOADED, throttle(evaluateRecordability, 1000));
      } else {
        el.src = url; // may or may not work
      }
    }


$('shuffleMusicBtn').addEventListener('click', ()=>{
  if(!hasBuiltOnce) return toast('Click Remix first');

  let did = false;

  if (localAudioList && localAudioList.length > 1){
    const keep = resolveLocalIndex('audio');
    shuffleInPlaceKeepIndex(localAudioList, null, keep);
    // keep the index aligned with the currently playing item
    window.localAudioIdx = keep;
    // do NOT reset src; let the current track finish, then 'ended' uses the new order
    updateSongTitle();
    refreshItemsIfOpen('audio');
    did = true;
  } else if (audioPlayer && audioPlayer.setShuffle){
    try{ audioPlayer.setShuffle(true); audioPlayer.nextVideo(); did = true; }catch(_){}
  }

  toast(did ? 'Shuffled Audio' : 'No audio playlist to shuffle');
});

$('shuffleVideoBtn').addEventListener('click', ()=>{
  if(!hasBuiltOnce) return toast('Click Remix first');

  let did = false;

  // Local primary: shuffle in place, keep the currently visible clip at its index
  if (localPrimaryList && localPrimaryList.length > 1){
    const keep = resolveLocalIndex('video');
    shuffleInPlaceKeepIndex(localPrimaryList, localPrimaryHandles, keep);
    // Do NOT change element.src or indices — seamless pair keeps playing; next will use new order
    refreshItemsIfOpen('video');
    did = true;
  }

  // Local overlay: idem
  if (localOverlayList && localOverlayList.length > 1){
    const keep = resolveLocalIndex('overlay');
    shuffleInPlaceKeepIndex(localOverlayList, localOverlayHandles, keep);
    refreshItemsIfOpen('overlay');
    did = true;
  }

  // YouTube fallback
  try{
    if(primaryYTPlayer && primaryYTPlayer.setShuffle){ primaryYTPlayer.setShuffle(true); primaryYTPlayer.nextVideo(); did = true; }
    if(overlayYTPlayer && overlayYTPlayer.setShuffle){ overlayYTPlayer.setShuffle(true); overlayYTPlayer.nextVideo(); did = true; }
  }catch(_){}

  toast(did ? 'Shuffled Video' : 'No video playlist to shuffle');
});

function buildVisuals(vSpec, oSpec){
  const c = $('backgroundVideoContainer');
  while (c.firstChild) c.removeChild(c.firstChild);
  destroyVisualPlayers();
  localPrimaryEl = null; 
  localOverlayEl = null;

  // ---------- PRIMARY: local list > direct MP4/HLS > YouTube ----------
  if (localPrimaryList.length){
    const { el, el2 } = buildSeamlessLocal(localPrimaryList, 'bg', 'video');
    localPrimaryEl  = el;
    window.localPrimaryEl2 = el2; // keep pause/resume logic happy
    attachPlayPauseLabelHandlersFor(localPrimaryEl);
  } else if (vSpec && (vSpec.kind==='file' || vSpec.kind==='hls')){
    localPrimaryEl = makeVideoEl('bg');
    c.appendChild(localPrimaryEl);
    if (vSpec.kind==='hls') attachHls(localPrimaryEl, $('videoUrl').value.trim(), 'primary');
    else { 
      localPrimaryEl.src = $('videoUrl').value.trim(); 
      localPrimaryEl.loop = true; 
    }
    wirePlaylistAdvance(localPrimaryEl, [{ url:$('videoUrl').value.trim() }], 'localPrimaryIdx', 'video');
    attachPlayPauseLabelHandlersFor(localPrimaryEl);
  } else if (vSpec && vSpec.kind==='youtube'){
    const vId = vSpec.isList ? vSpec.pid : vSpec.id;
    if (vId){
      const host = document.createElement('div'); 
      host.style.cssText='position:absolute;inset:0;';
      host.className='bg'; 
      c.appendChild(host);
      primaryYTPlayer = new YT.Player(host, {
        height:'390', width:'640',
        playerVars: vSpec.isList 
          ? { listType:'playlist', list:vId, autoplay:1, mute:1, controls:0 } 
          : { autoplay:1, mute:1, controls:0, loop:1, playlist:vId },
        events: {
          onReady: ev => { 
            const ifr = ev.target.getIframe(); 
            if (ifr){ 
              ifr.className='bg'; 
              ifr.style.pointerEvents='none'; 
              ensureCover(ifr); 
            } 
            applyFilters(); 
            queueRecordCheck(); 
          },
          onStateChange: e => { 
            updatePlayVisualsLabel(); 
            queueRecordCheck(); 
            if (e && e.data === YT.PlayerState.PLAYING) refreshItemsIfOpen('video'); 
          }
        }
      });
    } else { 
      alert('Invalid primary video URL'); 
    }

  } else if (vSpec && vSpec.kind==='vimeo'){
    const vId = vSpec.id;
    if (vId){
      const ifr = document.createElement('iframe'); 
      ifr.style.cssText='position:absolute;inset:0;width:100%;height:100%;border:0;';
      ifr.className='bg';
      c.appendChild(ifr);

      ifr.setAttribute('allow','autoplay; fullscreen; picture-in-picture');
      ifr.setAttribute('allowfullscreen','');
      const vh = vSpec.h ? `h=${encodeURIComponent(vSpec.h)}&` : '';
      ifr.src = `https://player.vimeo.com/video/${vId}?${vh}background=1&autoplay=1&muted=1&loop=1&controls=0&title=0&byline=0&portrait=0`;

      ifr.style.pointerEvents='none';
      ensureCover(ifr);
      applyFilters();

      if(!hasVimeoSDK()) { alert('Vimeo SDK failed to load. Check network/CSP.'); return; }
      primaryVimeoPlayer = new Vimeo.Player(ifr);
      primaryVimeoPlayer.on('play',  ()=>{ primaryVimeoPlaying=true;  updatePlayVisualsLabel(); });
      primaryVimeoPlayer.on('pause', ()=>{ primaryVimeoPlaying=false; updatePlayVisualsLabel(); });
      primaryVimeoPlayer.on('ended', ()=>{ primaryVimeoPlaying=false; updatePlayVisualsLabel(); });

      queueRecordCheck();
    } else { 
      alert('Invalid primary video URL'); 
    }

  }

  // ---------- OVERLAY: local list > direct MP4/HLS > YouTube ----------
  if (localOverlayList.length){
    const { el, el2 } = buildSeamlessLocal(localOverlayList, 'bg overlay', 'overlay');
    localOverlayEl  = el;
    window.localOverlayEl2 = el2; // keep pause/resume logic happy
    attachPlayPauseLabelHandlersFor(localOverlayEl);
  } else if (oSpec && (oSpec.kind==='file' || oSpec.kind==='hls')){
    localOverlayEl = makeVideoEl('bg overlay');
    c.appendChild(localOverlayEl);
    try{ localOverlayEl.style.zIndex='5'; }catch(_){ }
    if (oSpec.kind==='hls') attachHls(localOverlayEl, $('overlayUrl').value.trim(), 'overlay');
    else { 
      localOverlayEl.src = $('overlayUrl').value.trim(); 
      localOverlayEl.loop = true; 
    }
    wirePlaylistAdvance(localOverlayEl, [{ url:$('overlayUrl').value.trim() }], 'localOverlayIdx', 'overlay');
    localOverlayEl.style.mixBlendMode = 'screen';
    attachPlayPauseLabelHandlersFor(localOverlayEl);
  } else if (oSpec && oSpec.kind==='youtube'){
    const oId = oSpec.isList ? oSpec.pid : oSpec.id;
    if (oId){
      const host = document.createElement('div'); 
      host.style.cssText='position:absolute;inset:0;';
      host.className='bg overlay';
      host.style.zIndex='5'; 
      c.appendChild(host);
      overlayYTPlayer = new YT.Player(host, {
        height:'390', width:'640',
        playerVars: oSpec.isList 
          ? { listType:'playlist', list:oId, autoplay:1, mute:1, controls:0 } 
          : { autoplay:1, mute:1, controls:0, loop:1, playlist:oId },
        events: {
          onReady: ev => { 
            const ifr = ev.target.getIframe(); 
            if (ifr){ 
              ifr.className='bg overlay';
      ifr.style.zIndex='5'; 
              ifr.style.pointerEvents='none'; 
              ensureCover(ifr); 
              ifr.style.mixBlendMode='screen'; 
            } 
            applyFilters(); 
            queueRecordCheck(); 
          },
          onStateChange: e => { 
            updatePlayVisualsLabel(); 
            queueRecordCheck(); 
            if (e && e.data === YT.PlayerState.PLAYING) refreshItemsIfOpen('overlay'); 
          }
        }
      });
    } else { 
      alert('Invalid overlay video URL'); 
    }

  } else if (oSpec && oSpec.kind==='vimeo'){
    const oId = oSpec.id;
    if (oId){
      const ifr = document.createElement('iframe'); 
      ifr.style.cssText='position:absolute;inset:0;width:100%;height:100%;border:0;';
      ifr.className='bg overlay';
      ifr.style.zIndex='5';
      c.appendChild(ifr);

      ifr.setAttribute('allow','autoplay; fullscreen; picture-in-picture');
      ifr.setAttribute('allowfullscreen','');
      const oh = oSpec.h ? `h=${encodeURIComponent(oSpec.h)}&` : '';
      ifr.src = `https://player.vimeo.com/video/${oId}?${oh}background=1&autoplay=1&muted=1&loop=1&controls=0&title=0&byline=0&portrait=0`;

      ifr.style.pointerEvents='none';
      ensureCover(ifr);
      ifr.style.mixBlendMode='screen';
      applyFilters();

      if(!hasVimeoSDK()) { alert('Vimeo SDK failed to load. Check network/CSP.'); return; }
      overlayVimeoPlayer = new Vimeo.Player(ifr);
      overlayVimeoPlayer.on('play',  ()=>{ overlayVimeoPlaying=true;  updatePlayVisualsLabel(); });
      overlayVimeoPlayer.on('pause', ()=>{ overlayVimeoPlaying=false; updatePlayVisualsLabel(); });
      overlayVimeoPlayer.on('ended', ()=>{ overlayVimeoPlaying=false; updatePlayVisualsLabel(); });

      queueRecordCheck();
    } else { 
      alert('Invalid overlay video URL'); 
    }

  }

  /* ---- Fallbacks: reinsert active webcams if no element was created ---- */

  // Primary webcam fallback (kept behind overlay)
  if (!localPrimaryEl && window.primaryCamStream){
    const v = (typeof makeCamVideoEl === 'function') ? makeCamVideoEl('bg') : makeVideoEl('bg');
    v.srcObject = window.primaryCamStream;
    c.prepend(v); // primary below overlay
    window.localPrimaryEl = v;
    window.localPrimaryEl2 = null;
    setDot?.($('videoDot'), true);
    attachPlayPauseLabelHandlersFor?.(v);
  }

  // Overlay webcam fallback (blend + opacity restored, kept on top)
  if (!localOverlayEl && window.overlayCamStream){
    const v = (typeof makeCamVideoEl === 'function') ? makeCamVideoEl('bg overlay') : makeVideoEl('bg overlay');
    v.style.mixBlendMode = 'screen';
    v.style.opacity = (Number($('overlayOpacity')?.value ?? 50) / 100);
    v.srcObject = window.overlayCamStream;
    c.appendChild(v); // overlay above primary
    window.localOverlayEl = v;
    window.localOverlayEl2 = null;
    setDot?.($('overlayDot'), true);
    attachPlayPauseLabelHandlersFor?.(v);
  }

  // Final touches
  applyFilters();
  updatePlayVisualsLabel();
  queueRecordCheck?.();
}

    function ytIsPlaying(p){ try{ return p && p.getPlayerState && p.getPlayerState()===1; }catch(e){ return false; } }

    function isAnyVideoPlaying(){
      if(localPrimaryEl && !localPrimaryEl.paused) return true;
      if(localOverlayEl && !localOverlayEl.paused) return true;
      if(ytIsPlaying(primaryYTPlayer) || ytIsPlaying(overlayYTPlayer)) return true;
      if(primaryVimeoPlaying || overlayVimeoPlaying) return true;
      return false;
    }

    /* ========== Record Guard (preflight CORS + YT) ========== */
    const recordBtn=$('recordBtn'), recordBadge=$('recordBadge');

function queueRecordCheck(){
  /* one-shot model: checks run only after Remix */
}

    function setRecordStatus(status){
      recStatus = status;
      let disabled=true, title='';
      // Always show a helpful badge message (never leave "Waiting..." visible when recordable)
      if(status==='ok'){
        disabled=false; title='Record Remix';
        if(recordBadge) recordBadge.textContent='Recordable ✓';
      } else if(status==='checking'){
        disabled=true; title='';
        if(recordBadge) recordBadge.textContent='Checking…';
      } else if(status==='no-yt'){
        disabled=true; title='';
        if(recordBadge) recordBadge.textContent='Not recordable (YouTube/Vimeo)';
      } else if(status==='cors-blocked'){
        disabled=true; title='';
        if(recordBadge) recordBadge.textContent='Not recordable (CORS)';
      } else if(status==='no-visuals'){
        disabled=true; title='';
        if(recordBadge) recordBadge.textContent='Waiting…';
      } else {
        disabled=true; title='';
        if(recordBadge) recordBadge.textContent='Waiting…';
      }
      recordBtn.disabled = disabled;
      recordBtn.title = title;
    }

    function canDrawFrom(el){
      if(!el) return true; // not present -> doesn't block
      if(el.readyState < 2) return null; // not enough data yet
      if(el.videoWidth===0 || el.videoHeight===0) return null;
      const off = document.createElement('canvas');
      off.width = 1; off.height = 1;
      const ctx = off.getContext('2d');
      try{
        ctx.drawImage(el, 0, 0, 1, 1);
        ctx.getImageData(0,0,1,1);
        return true;
      }catch(e){
        return false;
      }
    }

function evaluateRecordability(){
  // YouTube/Vimeo iframe visuals cannot be captured to canvas.
  // Be robust: detect both SDK players AND raw iframes mounted in the visuals container.
  try{
    if (window.primaryYTPlayer || window.overlayYTPlayer || window.primaryVimeoPlayer || window.overlayVimeoPlayer || primaryVimeoPlayer || overlayVimeoPlayer){
      setRecordStatus('no-yt'); return;
    }
    const ifrs = document.querySelectorAll('#backgroundVideoContainer iframe');
    for (const ifr of ifrs){
      const src = (ifr.getAttribute('src') || '').toLowerCase();
      if (src.includes('youtube.com') || src.includes('youtube-nocookie.com') || src.includes('youtu.be') || src.includes('player.vimeo.com') || src.includes('vimeo.com')){
        setRecordStatus('no-yt'); return;
      }
    }
  }catch(_){}


  // Consider live webcams as visuals even with no local files/URLs
  const hasVisualEl = !!(window.localPrimaryEl || window.localOverlayEl);
  const hasCam      = !!(window.primaryCamStream || window.overlayCamStream);
  if (!(hasVisualEl || hasCam)){
    setRecordStatus('no-visuals'); return;
  }

  // If element is a webcam (<video srcObject>), accept once dimensions are ready
  const p = (window.localPrimaryEl && window.localPrimaryEl.srcObject)
    ? ((window.localPrimaryEl.videoWidth>0 && window.localPrimaryEl.videoHeight>0) ? true : null)
    : canDrawFrom(window.localPrimaryEl);

  const o = (window.localOverlayEl && window.localOverlayEl.srcObject)
    ? ((window.localOverlayEl.videoWidth>0 && window.localOverlayEl.videoHeight>0) ? true : null)
    : canDrawFrom(window.localOverlayEl);

  if (p===false || o===false){ setRecordStatus('cors-blocked'); return; }
  if (p===null  || o===null ){ setRecordStatus('checking');    return; }
  setRecordStatus('ok');
}

function evaluateRecordabilityOnce(timeoutMs=2500, intervalMs=120){
  try { setRecordStatus('checking'); } catch(_){}
  const start = performance.now();
  const stopStates = new Set(['ok','no-yt','cors-blocked','no-visuals']);

  (function tick(){
    try { evaluateRecordability(); } catch(_){}
    if (stopStates.has(window.recStatus)) return;
    if (performance.now() - start >= timeoutMs) return;
    setTimeout(tick, intervalMs);
  })();
}
    function updateRecordState(){
      // Call guard to set proper disabled + tooltip
      queueRecordCheck();
    }

    /* ========== Visuals toggle ========== */
    $('playVisualsBtn').addEventListener('click', ()=>{
      if(!hasBuiltOnce) return toast('Click Remix first');
      if(!anyVisual()) return;
      if(isAnyVideoPlaying()){
        if(localPrimaryEl && !localPrimaryEl.paused) localPrimaryEl.pause(); if(typeof localPrimaryEl2!=='undefined' && localPrimaryEl2 && !localPrimaryEl2.paused) localPrimaryEl2.pause();
        if(localOverlayEl && !localOverlayEl.paused) localOverlayEl.pause(); if(typeof localOverlayEl2!=='undefined' && localOverlayEl2 && !localOverlayEl2.paused) localOverlayEl2.pause();
        try{ if(primaryYTPlayer) primaryYTPlayer.pauseVideo(); }catch(e){}
        try{ if(overlayYTPlayer) overlayYTPlayer.pauseVideo(); }catch(e){}
        try{ if(primaryVimeoPlayer) primaryVimeoPlayer.pause(); }catch(e){}
        try{ if(overlayVimeoPlayer) overlayVimeoPlayer.pause(); }catch(e){}
      } else {
        if(localPrimaryEl) localPrimaryEl.play().catch(()=>{}); if(typeof localPrimaryEl2!=='undefined' && localPrimaryEl2) localPrimaryEl2.play().catch(()=>{});
        if(localOverlayEl) localOverlayEl.play().catch(()=>{}); if(typeof localOverlayEl2!=='undefined' && localOverlayEl2) localOverlayEl2.play().catch(()=>{});
        try{ if(primaryYTPlayer) primaryYTPlayer.playVideo(); }catch(e){}
        try{ if(overlayYTPlayer) overlayYTPlayer.playVideo(); }catch(e){}
        try{ if(primaryVimeoPlayer) primaryVimeoPlayer.play(); }catch(e){}
        try{ if(overlayVimeoPlayer) overlayVimeoPlayer.play(); }catch(e){}
      }
      updatePlayVisualsLabel();
      queueRecordCheck();
    });

    /* ========== Audio controls (unchanged) ========== */
    function onAudioReady(){
      try{ audioPlayer.setVolume($('volume').value); }catch(_){}
      updateSongTitle(); startSeek();
      updateButtons();
      updateStreamButtonState();
    }
    function onAudioStateChange(e){
      if(e.data===YT.PlayerState.PLAYING){ isPlaying=true; $('playPauseMusicBtn').textContent='Pause Audio'; updateSongTitle(); startSeek(); }
      if(e.data===YT.PlayerState.PAUSED){ isPlaying=false; $('playPauseMusicBtn').textContent='Play Audio'; }
      if(e.data===YT.PlayerState.ENDED){ if(isLooping){ try{audioPlayer.playVideo();}catch(_){ } } }
    }

    $('playPauseMusicBtn').addEventListener('click', ()=>{
      if(!hasBuiltOnce) return toast('Click Remix first');
      if(localAudioList.length || (localAudioEl && localAudioEl.src)){
        if(!localAudioEl){ localAudioEl=new Audio(); }
        if(!localAudioEl.src && localAudioList.length){ localAudioEl.src=localAudioList[localAudioIdx].url; localAudioEl.load(); }
        localAudioEl.volume = $('volume').value/100;
        if(localAudioEl.paused){ localAudioEl.play().catch(()=>{}); $('playPauseMusicBtn').textContent='Pause Audio'; startSeek(); }
        else { localAudioEl.pause(); $('playPauseMusicBtn').textContent='Play Audio'; }
      } else if(audioPlayer){
        const st = audioPlayer.getPlayerState && audioPlayer.getPlayerState();
        if(st===1){ audioPlayer.pauseVideo(); $('playPauseMusicBtn').textContent='Play Audio'; }
        else { audioPlayer.playVideo(); $('playPauseMusicBtn').textContent='Pause Audio'; startSeek(); }
      }
    });

    $('prevBtn').addEventListener('click', ()=>{
      if(localAudioList.length>1){
        localAudioIdx = (localAudioIdx-1+localAudioList.length)%localAudioList.length;
        if(!localAudioEl){ localAudioEl=new Audio(); }
        localAudioEl.src = localAudioList[localAudioIdx].url; localAudioEl.load(); localAudioEl.play().catch(()=>{});
        $('playPauseMusicBtn').textContent='Pause Audio'; updateSongTitle();
      } else if(audioPlayer && audioPlayer.previousVideo){ audioPlayer.previousVideo(); }
    });
    $('nextBtn').addEventListener('click', ()=>{
      if(localAudioList.length>1){
        localAudioIdx = (localAudioIdx+1)%localAudioList.length;
        if(!localAudioEl){ localAudioEl=new Audio(); }
        localAudioEl.src = localAudioList[localAudioIdx].url; localAudioEl.load(); localAudioEl.play().catch(()=>{});
        $('playPauseMusicBtn').textContent='Pause Audio'; updateSongTitle();
      } else if(audioPlayer && audioPlayer.nextVideo){ audioPlayer.nextVideo(); }
    });

    $('loopBtn').addEventListener('click', ()=>{
      isLooping=!isLooping;
      if(audioPlayer && audioPlayer.setLoop) audioPlayer.setLoop(isLooping);
      $('loopBtn').textContent='Loop Audio: ' + (isLooping? 'On':'Off');
    });

    $('volume').addEventListener('input', ()=>{
      if(localAudioEl){ localAudioEl.volume = $('volume').value/100; }
      if(audioPlayer && audioPlayer.setVolume){ audioPlayer.setVolume($('volume').value); }
    });

    $('seekbar').addEventListener('input', ()=>{
      const d = getAudioDuration();
      if(d>0){
        const t = ($('seekbar').value/100)*d;
        if(localAudioEl){ localAudioEl.currentTime = t; }
        else if(audioPlayer && audioPlayer.seekTo){ audioPlayer.seekTo(t, true); }
      }
    });

    function getAudioDuration(){ if(localAudioEl) return localAudioEl.duration||0; if(audioPlayer&&audioPlayer.getDuration) return audioPlayer.getDuration()||0; return 0; }
    function getAudioTime(){ if(localAudioEl) return localAudioEl.currentTime||0; if(audioPlayer&&audioPlayer.getCurrentTime) return audioPlayer.getCurrentTime()||0; return 0; }
    function startSeek(){ if(seekInterval) clearInterval(seekInterval); seekInterval=setInterval(()=>{ const d=getAudioDuration(); const t=getAudioTime(); if(d>0){ $('seekbar').value=(t/d)*100; } }, 1000); }
    function updateSongTitle(name){ if(name){ currentAudioTitle=name; } else if(audioPlayer && audioPlayer.getVideoData){ const vd=audioPlayer.getVideoData(); if(vd&&vd.title) currentAudioTitle = vd.title; } else if(localAudioList.length){ currentAudioTitle=localAudioList[localAudioIdx].name; } else if(localAudioEl && localAudioEl.src){ currentAudioTitle = localAudioEl.src.split('/').pop(); } else { currentAudioTitle='-'; } $('songTitle').textContent='Title: '+(currentAudioTitle||'-'); }

/* ========== Shuffle helpers (in-place; keep current index) ========== */
function swapPair(list, handles, i, j){
  if(i===j) return;
  const tmp = list[i]; list[i] = list[j]; list[j] = tmp;
  if (handles && handles.length === list.length){
    const th = handles[i]; handles[i] = handles[j]; handles[j] = th;
  }
}

/**
 * Fisher–Yates in place, but NEVER moves the element at keepIndex.
 * Also keeps `handles` aligned with `list`.
 */
function shuffleInPlaceKeepIndex(list, handles, keepIndex){
  if(!list || list.length < 2) return;
  const n = list.length;
  for (let i = n - 1; i > 0; i--){
    if (i === keepIndex) continue;
    let j = Math.floor(Math.random() * (i + 1));
    if (j === keepIndex){
      // nudge away from keepIndex
      j = (j === 0) ? 1 : j - 1;
    }
    swapPair(list, handles, i, j);
  }
}

/* Helpers to get current index in local lists */
function resolveLocalIndex(kind){
  if (kind === 'audio'){
    // rely on title/src; fall back to localAudioIdx if set
    if (window.localAudioEl && window.localAudioEl.currentSrc){
      const u = window.localAudioEl.currentSrc;
      const k = window.localAudioList.findIndex(x => x && x.url === u);
      if (k >= 0) return k;
    }
    return Math.max(0, window.localAudioIdx|0);
  }
  if (kind === 'video'){
    if (window.localPrimaryEl && window.localPrimaryEl.currentSrc){
      const u = window.localPrimaryEl.currentSrc;
      const k = window.localPrimaryList.findIndex(x => x && x.url === u);
      if (k >= 0) return k;
    }
    return 0;
  }
  if (kind === 'overlay'){
    if (window.localOverlayEl && window.localOverlayEl.currentSrc){
      const u = window.localOverlayEl.currentSrc;
      const k = window.localOverlayList.findIndex(x => x && x.url === u);
      if (k >= 0) return k;
    }
    return 0;
  }
  return 0;
}

/* Refresh items modal only if it’s open */
function refreshItemsIfOpen(kind){
  try{
    if (window.itemsModal && itemsModal.classList.contains('active')) {
      safeShowItems(kind);
    }
  }catch(_){}
}

    /* ========== Presets (same as v10) ========== */
    const PRESET_KEY = 'remix.presets.v3';
    function loadPresets(){ try{ return JSON.parse(localStorage.getItem(PRESET_KEY)||'[]'); }catch(_){ return []; } }
    function savePresets(list){ localStorage.setItem(PRESET_KEY, JSON.stringify(list)); }
    function collectState(){
      return {
        id: uuid(),
        name: '',
        audioUrl: $('audioUrl').value.trim(),
        videoUrl: $('videoUrl').value.trim(),
        overlayUrl: $('overlayUrl').value.trim(),
        localAudioNames: localAudioList.map(f=>f.name),
        localPrimaryNames: localPrimaryList.map(f=>f.name),
        localOverlayNames: localOverlayList.map(f=>f.name),
        handleKeys: { audio:null, primary:null, overlay:null },
        filters: {
          blur: $('filterBlur').value, gray: $('filterGrayscale').value, bright: $('filterBrightness').value,
          contrast: $('filterContrast').value, sepia: $('filterSepia').value, saturate: $('filterSaturate').value,
          invert: $('filterInvert').value, hue: $('filterHueRotate').value, overlayOpacity: $('overlayOpacity').value
        },
        volume: $('volume').value,
        loop: isLooping
      };
    }

    // Preset drawer open/close
    let presetDrawerOpen=false;
    const presetOverlay=$('presetOverlay'), presetDrawer=$('presetDrawer');
    function openPresetDrawer(){ presetOverlay.classList.add('active'); presetDrawer.classList.add('active'); presetDrawerOpen=true; renderPresetList(); }
    function closePresetDrawer(){ presetOverlay.classList.remove('active'); presetDrawer.classList.remove('active'); presetDrawerOpen=false; }
    $('managePresetsBtn').addEventListener('click', openPresetDrawer);
    $('closePresetDrawerBtn').addEventListener('click', closePresetDrawer);
    presetOverlay.addEventListener('click', closePresetDrawer);

    function renderPresetList(){
      const list = loadPresets();
      const box = $('presetList'); box.innerHTML='';
      if(!list.length){ box.innerHTML='<div style="opacity:.8">No presets yet. Click "Save Current" to create one.</div>'; return; }
      list.forEach((p,idx)=>{
        const row=document.createElement('div'); row.className='preset-row';
        row.innerHTML = `
          <input type="text" value="${p.name||''}" data-idx="${idx}" aria-label="Preset name">
          <div>
            <button data-act="apply" data-idx="${idx}">Apply</button>
            <button data-act="save" data-idx="${idx}">Overwrite</button>
            <button class="danger" data-act="del" data-idx="${idx}">Delete</button>
          </div>
<div class="details">
  <div class="detail"><span class="label">Audio:</span> ${p.audioUrl ? p.audioUrl : (p.localAudioNames?.join(' • ')||'—')}</div>
  <div class="detail"><span class="label">Video:</span> ${p.videoUrl ? p.videoUrl : (p.localPrimaryNames?.join(' • ')||'—')}</div>
  <div class="detail"><span class="label">Overlay:</span> ${p.overlayUrl ? p.overlayUrl : (p.localOverlayNames?.join(' • ')||'—')}</div>
</div>
        `;
        box.appendChild(row);
      });
      box.querySelectorAll('button').forEach(btn=>{
        btn.addEventListener('click', async e=>{
          const act=e.currentTarget.dataset.act, i=parseInt(e.currentTarget.dataset.idx,10);
          const list=loadPresets();
          if(Number.isNaN(i) || !list[i]) return;
          if(act==='apply'){ await applyPreset(list[i]); }
          else if(act==='save'){ const st=await saveOver(list[i]); st.name=list[i].name||`Preset ${i+1}`; list[i]=st; savePresets(list); toast('Preset overwritten'); renderPresetList(); }
          else if(act==='del'){ list.splice(i,1); savePresets(list); toast('Preset deleted'); renderPresetList(); }
        });
      });
      box.querySelectorAll('input[type="text"]').forEach(inp=>{
        inp.addEventListener('change', e=>{
          const i=parseInt(e.target.dataset.idx,10);
          const list=loadPresets(); if(Number.isNaN(i) || !list[i]) return;
          list[i].name = e.target.value || list[i].name || `Preset ${i+1}`;
          savePresets(list); toast('Renamed');
        });
      });
    }

    // Save current as named preset
    $('createPresetBtn').addEventListener('click', async ()=>{
      const name = $('newPresetName').value.trim() || 'New Preset';
      const st = await saveOver(); st.name = name;
      const list = loadPresets(); list.unshift(st); savePresets(list);
      $('newPresetName').value=''; toast('Preset saved'); renderPresetList();
    });

    async function saveOver(existing){
      const st = existing ? {...existing, ...collectState()} : collectState();
      if(window.showOpenFilePicker){
        if(localAudioHandles && localAudioHandles.length){ st.handleKeys.audio = st.handleKeys.audio || uuid(); await idbSet(st.handleKeys.audio, localAudioHandles); }
        if(localPrimaryHandles && localPrimaryHandles.length){ st.handleKeys.primary = st.handleKeys.primary || uuid(); await idbSet(st.handleKeys.primary, localPrimaryHandles); }
        if(localOverlayHandles && localOverlayHandles.length){ st.handleKeys.overlay = st.handleKeys.overlay || uuid(); await idbSet(st.handleKeys.overlay, localOverlayHandles); }
      }
      return st;
    }

    function setStateBasics(p){
      $('audioUrl').value = p.audioUrl || '';
      $('videoUrl').value = p.videoUrl || '';
      $('overlayUrl').value = p.overlayUrl || '';
      if(p.filters){
        $('filterBlur').value = p.filters.blur || 0;
        $('filterGrayscale').value = p.filters.gray || 0;
        $('filterBrightness').value = p.filters.bright || 100;
        $('filterContrast').value = p.filters.contrast || 100;
        $('filterSepia').value = p.filters.sepia || 0;
        $('filterSaturate').value = p.filters.saturate || 100;
        $('filterInvert').value = p.filters.invert || 0;
        $('filterHueRotate').value = p.filters.hue || 0;
        $('overlayOpacity').value = p.filters.overlayOpacity || 50;
      }
      $('volume').value = p.volume || 100;
      isLooping = !!p.loop;
      $('loopBtn').textContent = 'Loop Audio: ' + (isLooping? 'On' : 'Off');
      applyFilters();
      setDot($('audioDot'), localAudioList.length>0 || !!$('audioUrl').value.trim());
      setDot($('videoDot'), localPrimaryList.length>0 || !!$('videoUrl').value.trim());
      setDot($('overlayDot'), localOverlayList.length>0 || !!$('overlayUrl').value.trim());
      updateButtons();
      updateStreamButtonState();
    }

    async function tryLoadHandles(p){
      let any=false;
      try{
        if(p.handleKeys?.audio){ const hs = await idbGet(p.handleKeys.audio); if(hs && hs.length){ const files=await handlesToFiles(hs); if(files.length){ localAudioList=files; any=true; } } }
        if(p.handleKeys?.primary){ const hs = await idbGet(p.handleKeys.primary); if(hs && hs.length){ const files=await handlesToFiles(hs); if(files.length){ localPrimaryList=files; any=true; } } }
        if(p.handleKeys?.overlay){ const hs = await idbGet(p.handleKeys.overlay); if(hs && hs.length){ const files=await handlesToFiles(hs); if(files.length){ localOverlayList=files; any=true; } } }
      }catch(e){}
      return any;
    }

// Ensure any bg/overlay element fills the viewport like first load
function ensureCover(el){
  if(!el) return;
  el.classList.add('bg');
  Object.assign(el.style, {
    position:'absolute',
    inset:'0',
    width:'100vw',
    height:'100vh',
    objectFit:'cover',
    pointerEvents:'none'
  });
}
 
//  Keep YT iframes and <video> elements full-cover on resize
window.addEventListener('resize', () => {
  document
    .querySelectorAll('#backgroundVideoContainer iframe, #backgroundVideoContainer video')
    .forEach(ensureCover);
});

// Optional: do one pass right after players mount
setTimeout(() => {
  document
    .querySelectorAll('#backgroundVideoContainer iframe, #backgroundVideoContainer video')
    .forEach(ensureCover);
}, 0);

   async function applyPreset(p){
      setStateBasics(p);
      let loaded=false;
      if(window.showOpenFilePicker){ loaded = await tryLoadHandles(p); }
      const needAudioLocal = (!p.audioUrl && (p.localAudioNames?.length) && localAudioList.length===0);
      const needPrimaryLocal = (!p.videoUrl && (p.localPrimaryNames?.length) && localPrimaryList.length===0);
      const needOverlayLocal = (!p.overlayUrl && (p.localOverlayNames?.length) && localOverlayList.length===0);

      if(needAudioLocal || needPrimaryLocal || needOverlayLocal){
        openRestoreModal(p);
      } else {
        $('buildBtn').click();
        toast(loaded ? 'Preset loaded (remembered files)' : 'Preset loaded');
      }

// keep all background elements fully covering after applying a preset
setTimeout(()=>{
  document.querySelectorAll('#backgroundVideoContainer video, #backgroundVideoContainer iframe')
    .forEach(ensureCover);
}, 0);

    }

    // Restore modal logic (fallback when no handles or permission denied)
    const restoreOverlay = $('restoreOverlay');
    const restoreModal = $('restoreModal');
    let restorePreset = null;
    function openRestoreModal(p){
      restorePreset = p;
      $('restoreAudioStatus').textContent = 'Waiting for files…';
      $('restorePrimaryStatus').textContent = 'Waiting for files…';
      $('restoreOverlayStatus').textContent = 'Waiting for files…';
      restoreOverlay.classList.add('active');
      restoreModal.classList.add('active');
    }
    function closeRestoreModal(){ restoreOverlay.classList.remove('active'); restoreModal.classList.remove('active'); restorePreset=null; }

    function matchSelected(files, wantedNames){
      const map = new Map(); (wantedNames||[]).forEach(n=>map.set(n, null));
      const matched = [];
      [...files].forEach(f=>{ if(map.has(f.name) && !map.get(f.name)){ matched.push({url:URL.createObjectURL(f), name:f.name}); map.set(f.name, true); } });
      const missing = (wantedNames||[]).filter(n=>!map.get(n));
      return { matched, missing };
    }

    $('restorePickAudioBtn').addEventListener('click', ()=>$('restoreAudioFiles').click());
    $('restorePickPrimaryBtn').addEventListener('click', ()=>$('restorePrimaryFiles').click());
    $('restorePickOverlayBtn').addEventListener('click', ()=>$('restoreOverlayFiles').click());
    $('restoreCancelBtn').addEventListener('click', closeRestoreModal);
    $('restoreApplyBtn').addEventListener('click', ()=>{ closeRestoreModal(); $('buildBtn').click(); toast('Preset loaded'); });

    $('restoreAudioFiles').addEventListener('change', e=>{
      if(!restorePreset) return;
      const {matched, missing} = matchSelected(e.target.files, restorePreset.localAudioNames||[]);
      if(matched.length){ localAudioList = matched; updateSongTitle(); }
      $('restoreAudioStatus').innerHTML = `${matched.length} matched` + (missing.length? `, <span class="warn">${missing.length} missing</span>` : ' <span class="ok">✓</span>');
      setDot($('audioDot'), localAudioList.length>0 || !!$('audioUrl').value.trim());
    });
    $('restorePrimaryFiles').addEventListener('change', e=>{
      if(!restorePreset) return;
      const {matched, missing} = matchSelected(e.target.files, restorePreset.localPrimaryNames||[]);
      if(matched.length){ localPrimaryList = matched; }
      $('restorePrimaryStatus').innerHTML = `${matched.length} matched` + (missing.length? `, <span class="warn">${missing.length} missing</span>` : ' <span class="ok">✓</span>');
      setDot($('videoDot'), localPrimaryList.length>0 || !!$('videoUrl').value.trim());
    });
    $('restoreOverlayFiles').addEventListener('change', e=>{
      if(!restorePreset) return;
      const {matched, missing} = matchSelected(e.target.files, restorePreset.localOverlayNames||[]);
      if(matched.length){ localOverlayList = matched; }
      $('restoreOverlayStatus').innerHTML = `${matched.length} matched` + (missing.length? `, <span class="warn">${missing.length} missing</span>` : ' <span class="ok">✓</span>');
      setDot($('overlayDot'), localOverlayList.length>0 || !!$('overlayUrl').value.trim());
    });

    /* ========== Reset button ========== */
function clearAll(){
  try{ setWakeWanted(false); }catch(_){}
  try{ if (window.isRecording) stopRecording(); }catch(_){}

  // Stop mic
  try{ if (window.micStream) window.micStream.getTracks().forEach(t=>t.stop()); }catch(_){}
  try{ window.micStream = null; window.micSource = null; }catch(_){}
  try{ isMicEnabled = false; $('micRecBtn')?.classList.remove('recording'); }catch(_){}

  // Stop webcams
  try{ stopPrimaryCam?.(); $('primaryCamBtn')?.classList.remove('cam-active'); }catch(_){}
  try{ stopOverlayCam?.(); $('overlayCamBtn')?.classList.remove('cam-active'); }catch(_){}

  // Stop & destroy visual players
  try{ destroyVisualPlayers(); }catch(_){}
  try{ const c=$('backgroundVideoContainer'); if(c) c.innerHTML=''; }catch(_){}
  window.localPrimaryEl = null; window.localPrimaryEl2 = null;
  window.localOverlayEl = null; window.localOverlayEl2 = null;

  // Stop audio players
  try{
    if (window.localAudioEl){ window.localAudioEl.pause(); window.localAudioEl.removeAttribute('src'); window.localAudioEl.load?.(); }
  }catch(_){}
  try{
    if (window.audioPlayer && window.audioPlayer.destroy){
      try{ window.audioPlayer.stopVideo?.(); }catch(_){}
      window.audioPlayer.destroy();
    }
  }catch(_){}
  window.audioPlayer = null;

  // Clear lists + indices
  localAudioList=[]; localAudioIdx=0; localAudioHandles=null;
  localPrimaryList=[]; localPrimaryIdx=0; localPrimaryHandles=null;
  localOverlayList=[]; localOverlayIdx=0; localOverlayHandles=null;

  // Clear file inputs
  try{ $('audioFiles').value=''; $('primaryFiles').value=''; $('overlayFiles').value=''; }catch(_){}
  try{ $('restoreAudioFiles').value=''; $('restorePrimaryFiles').value=''; $('restoreOverlayFiles').value=''; }catch(_){}

  // Clear URL inputs
  $('audioUrl').value='';
  $('videoUrl').value='';
  $('overlayUrl').value='';

  // Reset hints + dots
  $('audioHint').textContent='';
  $('videoHint').textContent='';
  $('overlayHint').textContent='';
  setDot($('audioDot'), false);
  setDot($('videoDot'), false);
  setDot($('overlayDot'), false);

  // Reset UI state
  hasBuiltOnce=false;
  isPlaying=false;
  currentAudioTitle='-';
  $('songTitle').textContent='Title: -';
  $('seekbar').value=0;
  $('playPauseMusicBtn').textContent='Play Audio';
  $('playVisualsBtn').textContent='Play Video';

  try{ setRecordStatus('no-visuals'); }catch(_){}
  try{ updateStreamButtonState(); }catch(_){}
  updateButtons();
  toast('Cleared');
}
$('resetBtn').addEventListener('click', clearAll);


    $('resetBtn').addEventListener('click', ()=>{ window.location.reload(); });

/* ========== Fullscreen ========== */
let __fsWasPlaying = false;
let __fsWasLocalPrimaryPlaying = false;
let __fsWasLocalOverlayPlaying = false;
$('fullscreenBtn').addEventListener('click', ()=>{
  setWakeWanted(true); // keep display awake while in fullscreen

  // Remember state so we can resume local playback when exiting fullscreen
  __fsWasPlaying = isAnyVideoPlaying();
  __fsWasLocalPrimaryPlaying = !!(window.localPrimaryEl && !window.localPrimaryEl.paused);
  __fsWasLocalOverlayPlaying = !!(window.localOverlayEl && !window.localOverlayEl.paused);

  const c = $('backgroundVideoContainer');
  if(c.requestFullscreen) c.requestFullscreen();
  else if(c.webkitRequestFullscreen) c.webkitRequestFullscreen();
  else if(c.msRequestFullscreen) c.msRequestFullscreen();
});

// Some browsers pause <video> when leaving fullscreen; resume only if it was playing before.
document.addEventListener('fullscreenchange', ()=>{
  if (document.fullscreenElement) return;
  if (!__fsWasPlaying) return;
  try{
    if (__fsWasLocalPrimaryPlaying && window.localPrimaryEl?.paused) window.localPrimaryEl.play().catch(()=>{});
    if (__fsWasLocalOverlayPlaying && window.localOverlayEl?.paused) window.localOverlayEl.play().catch(()=>{});
  }catch(_){}
});


// --- Stream popup (live updates + filters, no observer, no wildcard CSS) ---
document.getElementById('streamBtn')?.addEventListener('click', () => {
  const src = document.getElementById('backgroundVideoContainer');
  if (!src) return (window.toast?.('No visuals container found') || alert('No visuals container found'));

// If we're using only local videos, we want them to keep playing after Stream closes.
const __streamWasLocalPrimaryPlaying = !!(window.localPrimaryEl && !window.localPrimaryEl.paused);
const __streamWasLocalOverlayPlaying = !!(window.localOverlayEl && !window.localOverlayEl.paused);

  const w = window.open('', 'VITUREMA_OUTPUT', 'popup=yes,width=1280,height=720');
  if (!w) return (window.toast?.('Popup blocked — allow popups') || alert('Popup blocked — allow popups'));

  // Minimal shell (no wildcard "*", fewer style recalcs)
  w.document.open();
  w.document.write(`<!doctype html><html><head>
<meta charset="utf-8">
<title>Stream – VITUREMA Studio™</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
  html,body{margin:0;height:100%;background:#000;overflow:hidden}
  #root{position:fixed;inset:0;background:#000}
  #root>#backgroundVideoContainer{
    position:fixed;inset:0;background:#000;overflow:hidden;z-index:1 !important;
  }
  video,iframe{position:absolute;inset:0;width:100vw;height:100vh}
  video{object-fit:cover}
  iframe{pointer-events:none}

  /* ensure overlays stay above primary, especially when primary is local videos with z-index */
  #backgroundVideoContainer .bg{z-index:1}
  #backgroundVideoContainer .overlay{z-index:5}
</style>
</head><body><div id="root"></div></body></html>`);
  w.document.close();

  const ready = () => {
    try { w.document.title = 'Stream – VITUREMA Studio™'; } catch {}

    // Placeholder so main app still has a target id
    const ph = document.createElement('div');
    ph.id = 'backgroundVideoContainer';
    ph.style.cssText = 'position:fixed;inset:0;z-index:-2;background:#000;overflow:hidden';
    src.parentNode.replaceChild(ph, src);

    // Move the LIVE node into the popup
    const moved = w.document.adoptNode ? w.document.adoptNode(src) : src;
    w.document.getElementById('root').appendChild(moved);
    moved.style.cssText = 'position:fixed;inset:0;background:#000;overflow:hidden;z-index:1';

    // Resume videos (some browsers pause after adoptNode)
    moved.querySelectorAll('video').forEach(v=>{
      try{ v.muted = true; v.playsInline = true; v.play().catch(()=>{}); }catch(_){}
    });
    try{ window.primaryYTPlayer?.playVideo?.(); }catch(_){}
    try{ window.overlayYTPlayer?.playVideo?.(); }catch(_){}

    // Keep a reference so filters can update popup too
    window.streamWin = w;

    // PATCH your "$" helper so future builds target the moved container (live updates)
    const orig$ = window.$;
    if (typeof orig$ === 'function') {
      window.$ = function(id){ if(id==='backgroundVideoContainer' && moved) return moved; return orig$(id); };
    }

    // Maintain cover sizing in the popup only (cheaper than both docs)
    const cover = () => {
      moved.querySelectorAll('video,iframe').forEach(el => { try{ ensureCover?.(el); }catch(_){ } });
    };
    cover();
    w.addEventListener('resize', cover);

    // Sync current filters into popup now
    try { applyFilters(); } catch {}

    // Optional: fullscreen the popup
    try{
      const fsEl = w.document.documentElement;
      (fsEl.requestFullscreen || fsEl.webkitRequestFullscreen || fsEl.msRequestFullscreen)?.call(fsEl);
    }catch(_){}

    // Restore when popup closes
    w.addEventListener('beforeunload', ()=>{
      try{
        const back = document.adoptNode ? document.adoptNode(moved) : moved;
        back.style.cssText = 'position:fixed;inset:0;z-index:-2;background:#000;overflow:hidden';
        ph.replaceWith(back);
      }catch(_){}
      if (typeof orig$ === 'function') window.$ = orig$;

// Resume local playback if it was playing when Stream was opened.
try{
  if (__streamWasLocalPrimaryPlaying) window.localPrimaryEl?.play?.().catch(()=>{});
  if (__streamWasLocalOverlayPlaying) window.localOverlayEl?.play?.().catch(()=>{});
}catch(_){}
      window.streamWin = null;
      w.removeEventListener('resize', cover);
    }, { once:true });
  };

  if (w.document.readyState === 'complete' || w.document.readyState === 'interactive') ready();
  else w.addEventListener('load', ready, { once:true });
});

// Keep the popup “awake” too
function armPopupWakeLock(win){
  try{
    win.addEventListener('focus', ()=>setWakeWanted(true));
    win.addEventListener('blur',  ()=>setWakeWanted(false));
    win.addEventListener('beforeunload', ()=>setWakeWanted(false), { once:true });
  }catch(_){}
}

/* ========== Wake Lock (fullscreen OR stream popup) ========== */
let wakeLock = null;
let wakeWanted = false;              // <-- single source of truth
/* ---- iOS/Safari fallback: silent audio keeps device awake ---- */
let keepAliveCtx, keepAliveOsc, keepAliveGain;

function startAudioKeepAlive(win = window){
  try{
    if (keepAliveCtx && keepAliveCtx.state !== 'closed') return;
    const Ctx = win.AudioContext || win.webkitAudioContext;
    if (!Ctx) return;
    keepAliveCtx = new Ctx();
    keepAliveGain = keepAliveCtx.createGain(); keepAliveGain.gain.value = 0;
    keepAliveGain.connect(keepAliveCtx.destination);
    keepAliveOsc = keepAliveCtx.createOscillator();
    keepAliveOsc.frequency.value = 0.0001;
    keepAliveOsc.connect(keepAliveGain);
    keepAliveOsc.start();
  }catch(_){}
}
function stopAudioKeepAlive(){
  try{ keepAliveOsc?.stop(); }catch(_){}
  try{ keepAliveCtx?.close(); }catch(_){}
  keepAliveOsc = keepAliveGain = keepAliveCtx = null;
}

async function requestWakeLock(){
  // If API exists, try it; otherwise fallback to silent audio
  if (!('wakeLock' in navigator)){
    startAudioKeepAlive(); return;
  }
  try{
    // release old handle first to avoid duplicates
    if (wakeLock){ try{ await wakeLock.release(); }catch(_){ } wakeLock = null; }
    wakeLock = await navigator.wakeLock.request('screen');
    wakeLock.addEventListener?.('release', ()=>{ wakeLock = null; });
    // we have a real lock, no need for the audio fallback
    stopAudioKeepAlive();
  }catch(_){
    // denied or not allowed in this state -> try fallback
    startAudioKeepAlive();
  }
}
function releaseWakeLock(){
  try{ wakeLock?.release?.(); }catch(_){}
  wakeLock = null;
  stopAudioKeepAlive();
}

/* Public switch you can call from your buttons */
function setWakeWanted(on){
  wakeWanted = !!on;
  if (wakeWanted) requestWakeLock();
  else releaseWakeLock();
}

/* Re-apply when tab becomes visible again if we still want it */
document.addEventListener('visibilitychange', ()=>{
  if (document.visibilityState === 'visible'){
    if (wakeWanted) requestWakeLock();
  } else {
    // tab hidden – keep the handle if browser allows; do nothing here
  }
});

/* Enter/exit fullscreen: prefer to keep lock while wanted */
document.addEventListener('fullscreenchange', ()=>{
  if (document.fullscreenElement){
    wakeWanted = true;                // a user just asked for FS -> we want it
    requestWakeLock();
    if (!('wakeLock' in navigator)) startAudioKeepAlive();
  } else {
    // only release if the app no longer wants to stay awake
    if (!wakeWanted){ releaseWakeLock(); }
  }
});

/* Helpful: re-request on next user gesture (some browsers require it) */
['pointerdown','keydown'].forEach(ev=>{
  window.addEventListener(ev, ()=>{ if (wakeWanted) requestWakeLock(); }, {passive:true});
});

/* ========== Popup helper: arm wake lock inside the stream window ========== */
function armPopupWakeLock(win){
  if (!win) return;
  const tryReq = async ()=>{
    try{
      if ('wakeLock' in win.navigator){
        const wl = await win.navigator.wakeLock.request('screen');
        wl.addEventListener?.('release', ()=>{ /* ignore */ });
        // stop popup fallback if any
        win._keepAliveStop?.();
      }else{
        // popup fallback
        win._keepAliveStop?.(); // stop old if any
        win._keepAliveStop = (function(){
          let ac, osc, g;
          try{
            const Ctx = win.AudioContext || win.webkitAudioContext;
            if (!Ctx) return ()=>{};
            ac = new Ctx(); g = ac.createGain(); g.gain.value = 0; g.connect(ac.destination);
            osc = ac.createOscillator(); osc.frequency.value = 0.0001; osc.connect(g); osc.start();
          }catch(_){}
          return ()=>{
            try{ osc?.stop(); }catch(_){}
            try{ ac?.close(); }catch(_){}
            ac = osc = g = null;
          };
        })();
      }
    }catch(_){
      // fallback in popup if request fails
      if (!win._keepAliveStop) armPopupWakeLock(win); // will create fallback
    }
  };
  const hook = ()=>{ tryReq(); };
  // do it now & re-apply on visibility/focus
  if (win.document.readyState === 'complete' || win.document.readyState === 'interactive') hook();
  else win.addEventListener('load', hook, {once:true});
  win.document.addEventListener('visibilitychange', ()=>{ if (win.document.visibilityState==='visible') tryReq(); });
  win.addEventListener('focus', tryReq);
}

    /* ========== Items viewer (local + YT) ========== */
    const itemsOverlay=$('itemsOverlay'), itemsModal=$('itemsModal'), itemsInfo=$('itemsInfo');
    const localListBox=$('localList'), ytItemsBox=$('ytItems');
let currentItemsKindOpen=null;
function safeShowItems(kind){ try{ showItems(kind); }catch(e){} }


function closeItems(){ itemsOverlay.classList.remove('active'); itemsModal.classList.remove('active'); currentItemsKindOpen=null; stopItemsTicker(); }
    itemsOverlay.addEventListener('click', closeItems); $('closeItemsBtn').addEventListener('click', closeItems);

    function renderLocal(kind, items, currentIdx){
      localListBox.innerHTML='';
      // additionally show direct URL (non-YT) if provided
      let extraItem=null;
      if(kind==='video'){
        const cs=classify($('videoUrl').value.trim()); if(cs && (cs.kind==='file'||cs.kind==='hls')) extraItem={url:$('videoUrl').value.trim(), name:'(remote '+cs.kind.toUpperCase()+')'};
      }
      if(kind==='overlay'){
        const cs=classify($('overlayUrl').value.trim()); if(cs && (cs.kind==='file'||cs.kind==='hls')) extraItem={url:$('overlayUrl').value.trim(), name:'(remote '+cs.kind.toUpperCase()+')'};
      }
      if(kind==='audio'){
        const cs=classify($('audioUrl').value.trim()); if(cs && cs.kind==='audio') extraItem={url:$('audioUrl').value.trim(), name:'(remote AUDIO)'};
      }
      const combined = items.slice();
      if(extraItem) combined.unshift(extraItem);

      if(!combined.length){ localListBox.innerHTML = '<div class="muted">No local items.</div>'; return; }
      combined.forEach((obj, i)=>{
        const row=document.createElement('div'); row.className='localRow' + (i===currentIdx? ' active':'');
        row.innerHTML = `<div class="index">#${i+1}</div>
                         <div class="badge">${kind==='audio'?'AUDIO':kind==='video'?'VIDEO':'OVERLAY'}</div>
                         <div class="name" title="${obj.name||''}">${obj.name||obj.url||'(unnamed)'}</div>`;
        row.addEventListener('click', ()=>{
          if(!hasBuiltOnce) { toast('Click Remix first'); return; }
          if(kind==='audio'){
            if(obj.url && !items.length){ // remote audio single
              if(!localAudioEl) localAudioEl=new Audio();
              localAudioEl.crossOrigin='anonymous'; localAudioEl.src=obj.url; localAudioEl.load(); localAudioEl.play().catch(()=>{});
              $('playPauseMusicBtn').textContent='Pause Audio'; updateSongTitle(obj.url.split('/').pop());
            } else if(items.length){
              localAudioIdx = Math.max(0, i-(extraItem?1:0));
              if(!localAudioEl) localAudioEl=new Audio();
              localAudioEl.src = items[localAudioIdx].url; localAudioEl.load(); localAudioEl.play().catch(()=>{});
              $('playPauseMusicBtn').textContent='Pause Audio'; updateSongTitle(items[localAudioIdx].name);
            }
          } else if(kind==='video'){
            if(obj.url && !items.length){ $('videoUrl').value=obj.url; $('buildBtn').click(); }
            else { localPrimaryIdx = Math.max(0, i-(extraItem?1:0)); if(localPrimaryEl){ localPrimaryEl.src = items[localPrimaryIdx].url; localPrimaryEl.play().catch(()=>{}); } }
          } else if(kind==='overlay'){
            if(obj.url && !items.length){ $('overlayUrl').value=obj.url; $('buildBtn').click(); }
            else { localOverlayIdx = Math.max(0, i-(extraItem?1:0)); if(localOverlayEl){ localOverlayEl.src = items[localOverlayIdx].url; localOverlayEl.play().catch(()=>{}); } }
          }
          document.querySelectorAll('.localRow').forEach(el=>el.classList.remove('active'));
          row.classList.add('active');
        });
        localListBox.appendChild(row);
      });
    }

    function renderYT(kind, ids, idx){
      ytItemsBox.innerHTML='';
      if(!ids || !ids.length){ ytItemsBox.innerHTML = '<div class="muted">No YouTube playlist items.</div>'; return; }
      ids.forEach((id, i)=>{
        const card = document.createElement('div'); card.className = 'ytThumb' + (i===idx ? ' active' : '');
        card.innerHTML=`<img src="https://i.ytimg.com/vi/${id}/hqdefault.jpg" alt="${id} thumbnail">
                        <div class="cap">#${i+1} • ${id} ${i===idx? '<small>• now playing</small>':''}</div>`;
        card.addEventListener('click', ()=>{
          if(!hasBuiltOnce) { toast('Click Remix first'); return; }
          try{
            if(kind==='audio' && audioPlayer && audioPlayer.playVideoAt){ audioPlayer.playVideoAt(i); }
            if(kind==='video' && primaryYTPlayer && primaryYTPlayer.playVideoAt){ primaryYTPlayer.playVideoAt(i); }
            if(kind==='overlay' && overlayYTPlayer && overlayYTPlayer.playVideoAt){ overlayYTPlayer.playVideoAt(i); }
          }catch(e){}
        });
        ytItemsBox.appendChild(card);
      });
    }

function resolveLocalIndex(kind){
  try{
    if(kind==='audio') return (typeof localAudioIdx!=='undefined') ? localAudioIdx : 0;
    const list = (kind==='video') ? localPrimaryList : localOverlayList;
    const v = (kind==='video') ? (window.localPrimaryEl || null) : (window.localOverlayEl || null);
    if(list && list.length && v){
      const cur = v.currentSrc || v.src || '';
      const i = list.findIndex(it => it && it.url === cur);
      if(i>=0){
        if(kind==='video') window.localPrimaryIdx = i; else window.localOverlayIdx = i;
        return i;
      }
    }
    return (kind==='video') ? (typeof localPrimaryIdx!=='undefined'? localPrimaryIdx : 0)
                            : (typeof localOverlayIdx!=='undefined'? localOverlayIdx : 0);
  }catch(_){ return 0; }
}

function refreshItemsIfOpen(kind){
  try{
    const m = document.getElementById('itemsModal');
    if(m && m.classList.contains('active') && window.currentItemsKindOpen===kind){
      try{ showItems(kind); }catch(_){}
    }
  }catch(_){}
}

let itemsLiveTicker = null;
function startItemsTicker(kind){
  stopItemsTicker();
  itemsLiveTicker = setInterval(async ()=>{
    try{
      const m = document.getElementById('itemsModal');
      if(!m || !m.classList.contains('active')){ stopItemsTicker(); return; }

      // Local highlight
      const idxLoc = resolveLocalIndex(kind);
      document.querySelectorAll('#localList .localRow')
        .forEach((el,i)=> el.classList.toggle('active', i===idxLoc));

      // YT highlight
      await whenYTReady;
      let p=null;
      if(kind==='audio') p=audioPlayer;
      if(kind==='video') p=primaryYTPlayer;
      if(kind==='overlay') p=overlayYTPlayer;
      if(p && p.getPlaylist){
        const ids = p.getPlaylist()||[];
        let idx = p.getPlaylistIndex ? p.getPlaylistIndex() : -1;
        if((idx===null || idx===undefined || idx<0) && p.getVideoData){
          const vd = p.getVideoData(); if(vd && vd.video_id){ const j=ids.indexOf(vd.video_id); if(j>=0) idx=j; }
        }
        const cards = document.querySelectorAll('#ytItems .ytThumb');
        cards.forEach((el,i)=> el.classList.toggle('active', i===idx));
      }
    }catch(_){}
  }, 250);
}
function stopItemsTicker(){ if(itemsLiveTicker){ clearInterval(itemsLiveTicker); itemsLiveTicker=null; } }

    async function showItems(kind){
      itemsInfo.textContent = (kind==='audio'?'Audio':kind==='video'?'Primary Video':'Overlay Video') + ' — Local/Remote & YouTube';
if(kind==='audio')  renderLocal('audio',  localAudioList,    resolveLocalIndex('audio'));
if(kind==='video')  renderLocal('video',  localPrimaryList,  resolveLocalIndex('video'));
if(kind==='overlay')renderLocal('overlay',localOverlayList,  resolveLocalIndex('overlay'));
      await whenYTReady;
      let p=null;
      if(kind==='audio') p=audioPlayer;
      if(kind==='video') p=primaryYTPlayer;
      if(kind==='overlay') p=overlayYTPlayer;
      try{
        const ids = p && p.getPlaylist ? (p.getPlaylist()||[]) : [];

let idx = p && p.getPlaylistIndex ? p.getPlaylistIndex() : null;
if((idx===null || idx===undefined || idx<0) && p && p.getVideoData){
  try{
    const vd = p.getVideoData();
    const ids = (p.getPlaylist && p.getPlaylist()) || [];
    if(vd && vd.video_id){ const j = ids.indexOf(vd.video_id); if(j>=0) idx=j; }
  }catch(_){}
}
        renderYT(kind, ids, idx);
      }catch(e){
        renderYT(kind, [], null);
      }
      itemsOverlay.classList.add('active'); itemsModal.classList.add('active'); startItemsTicker(kind);
      startItemsTicker(kind);
    }

$('viewAudioItemsBtn').addEventListener('click', ()=>{ currentItemsKindOpen='audio'; showItems('audio'); startItemsTicker('audio'); });
$('viewVideoItemsBtn').addEventListener('click', ()=>{ currentItemsKindOpen='video'; showItems('video'); startItemsTicker('video'); });
$('viewOverlayItemsBtn').addEventListener('click', ()=>{ currentItemsKindOpen='overlay'; showItems('overlay'); startItemsTicker('overlay'); });

/* ========== Recorder (merged + filter-aware) ========== */
const recOverlay = $('recModalOverlay'), recModal = $('recModal');
const recInput   = $('recName'), recSave  = $('recSaveBtn'), recClose = $('recCloseBtn');
// Removed: convertBar / convertFill / convertPct / convertMp4 (we're not converting anymore)

recordBtn.addEventListener('click', ()=>{ if(isRecording) stopRecording(); else startRecording(); });

function setupRecCanvas(){
  if(!recCanvas){
    recCanvas = document.createElement('canvas');
    recCtx = recCanvas.getContext('2d');
  }
  resizeRecCanvas();
}

function resizeRecCanvas(){
  if (window.isRecording) return; // keep chosen size during recording
  recCanvas.width  = window.innerWidth;
  recCanvas.height = window.innerHeight;
}
window.addEventListener('resize', ()=>{ if(recCanvas) resizeRecCanvas(); });

function canDrawCheck(){
  try{ if(recCtx) recCtx.getImageData(0,0,1,1); return true; }catch(e){ return false; }
}

function drawCover(ctx, video, W, H){
  const vw = Number(video.videoWidth)  || 16;
  const vh = Number(video.videoHeight) || 9;
  if(!vw || !vh) return;
  const s  = Math.max(W/vw, H/vh);
  const dw = vw*s, dh = vh*s;
  const dx = (W - dw)/2, dy = (H - dh)/2;
  ctx.drawImage(video, dx, dy, dw, dh);
}

/* ---- One-time canvas feature checks (guarded; no duplicates) ---- */
if (typeof window.CANVAS_SUPPORTS_SCREEN === 'undefined') {
  (function(){
    const c = document.createElement('canvas');
    const x = c.getContext('2d');
    let ok = false;
    try { x.globalCompositeOperation = 'screen'; ok = (x.globalCompositeOperation === 'screen'); } catch(_) {}
    window.CANVAS_SUPPORTS_SCREEN = ok;
  })();
}
if (typeof window.CANVAS_SUPPORTS_FILTER === 'undefined') {
  (function(){
    const c = document.createElement('canvas');
    const x = c.getContext('2d');
    window.CANVAS_SUPPORTS_FILTER = !!(x && ('filter' in x));
  })();
}
if (typeof window._warnedNoCanvasFilter === 'undefined') {
  window._warnedNoCanvasFilter = false;
}

/* ---- Safe slider value reader ---- */
function val(id, fallback){
  try{
    const el = (typeof $ === 'function') ? $(id) : document.getElementById(id);
    if (!el || el.value == null) return fallback;
    const n = Number(el.value);
    return Number.isNaN(n) ? fallback : n;
  }catch(_){ return fallback; }
}

/* ---- Build same CSS filter string used by your UI for PRIMARY (.bg) ---- */
function getCurrentFilterString(){
  return [
    `blur(${val('filterBlur', 0)}px)`,
    `grayscale(${val('filterGrayscale', 0)}%)`,
    `brightness(${val('filterBrightness', 100)}%)`,
    `contrast(${val('filterContrast', 100)}%)`,
    `sepia(${val('filterSepia', 0)}%)`,
    `saturate(${val('filterSaturate', 100)}%)`,
    `invert(${val('filterInvert', 0)}%)`,
    `hue-rotate(${val('filterHueRotate', 0)}deg)`
  ].join(' ');
}
function getOverlayOpacity(){ return val('overlayOpacity', 0) / 100; }

// Set to false if you want the overlay unfiltered (DOM-style) but still blended.
const APPLY_FILTER_TO_OVERLAY = true;

// Recording sizes (selector -> width/height)
const REC_SIZES = {
  '1280x720':  {w:1280,  h:720},
  '1920x1080': {w:1920, h:1080},
  '3840x2160': {w:3840, h:2160}, // 4K UHD
};
function getSelectedRecSize(){
  const sel = document.getElementById('recRes');
  const key = sel?.value || '1920x1080';
  return REC_SIZES[key] || REC_SIZES['1920x1080'];
}

function drawFrame(){
  if(!recCtx || !recCanvas) return;

  const W = recCanvas.width, H = recCanvas.height;
  recCtx.clearRect(0,0,W,H);

  const filterStr = getCurrentFilterString();

  // Helper: draw like object-fit: cover
  const cover = (v)=>{
    if(!v || v.readyState < 2) return false;
    try{ drawCover(recCtx, v, W, H); return true; }catch(_){ return false; }
  };

  // ===== PRIMARY (filtered) =====
  recCtx.filter = window.CANVAS_SUPPORTS_FILTER ? filterStr : 'none';

  let drewPrimary = cover(window.localPrimaryEl);
  if(!drewPrimary && window._lastPrimaryFrame){
    try{ drawCover(recCtx, window._lastPrimaryFrame, W, H); }catch(_){}
  } else if (drewPrimary){
    window._lastPrimaryFrame = window.localPrimaryEl;
  }

  // ===== OVERLAY (opacity + blend; optional filters) =====
  const op = getOverlayOpacity();
  if (window.localOverlayEl && op > 0){
    recCtx.save();
    recCtx.filter = (window.CANVAS_SUPPORTS_FILTER && APPLY_FILTER_TO_OVERLAY) ? filterStr : 'none';
    recCtx.globalAlpha = op;
    recCtx.globalCompositeOperation = window.CANVAS_SUPPORTS_SCREEN ? 'screen' : 'lighter';

    let drewOverlay = cover(window.localOverlayEl);
    if(!drewOverlay && window._lastOverlayFrame){
      try{ drawCover(recCtx, window._lastOverlayFrame, W, H); }catch(_){}
    } else if (drewOverlay){
      window._lastOverlayFrame = window.localOverlayEl;
    }

    recCtx.restore();
  }

  // Reset context state
  recCtx.filter = 'none';
  recCtx.globalAlpha = 1;
  recCtx.globalCompositeOperation = 'source-over';

  recRAF = requestAnimationFrame(drawFrame);
}

    function tsName(ext){ const d=new Date(), p=n=>String(n).padStart(2,'0'); return `remix-${d.getFullYear()}${p(d.getMonth()+1)}${p(d.getDate())}-${p(d.getHours())}${p(d.getMinutes())}${p(d.getSeconds())}.${ext}`; }

    function recordEligible(){
      return recStatus==='ok';
    }

// --- Recorder quality helpers ---
function pickBestMime(){
  const candidates = [
    'video/webm;codecs=vp9,opus',   // best quality in Chrome/Edge/Firefox
    'video/webm;codecs=vp8,opus',
    'video/webm',                   // generic WebM
    'video/mp4;codecs=avc1.42E01E,mp4a.40.2' // Safari fallback (if supported)
  ];
  return candidates.find(t => MediaRecorder.isTypeSupported?.(t));
}

// Choose your recording FPS and bitrates here
const REC_FPS   = 30;          // fps
const REC_VBPS  = 20_000_000;  // Mbps video
const REC_ABPS  = 192_000;     // kbps audio

async function startRecording(){
  if(!recordEligible()){
    toast(recordBtn.title || 'Sources not recordable');
    return;
  }

  // 1) Prep canvas & fix it to the selected resolution
  setupRecCanvas();
  const { w, h } = getSelectedRecSize();
  recCanvas.width = w;
  recCanvas.height = h;

  // Start the draw loop (this paints filters into the canvas)
  recRAF = requestAnimationFrame(drawFrame);

  // 2) Re-check CORS/taint
  if(!canDrawCheck()){
    cancelAnimationFrame(recRAF);
    setRecordStatus('cors-blocked');
    toast('Cannot record: remote stream blocks drawing (no CORS)');
    return;
  }

  // 3) Capture canvas (visuals + filters)
  const REC_FPS  = 30;                // frame rate
  const VBPS     = 20_000_000;        // 20 Mbps (your request)
  const ABPS     = 192_000;           // 192 kbps audio
  const canvasStream = recCanvas.captureStream(REC_FPS);

  // 4) Optional audio (localAudioEl / list)
  let mixedStream = canvasStream;

  const needAudio =
    (localAudioList.length > 0) ||
    (localAudioEl && localAudioEl.src) ||
    !!window.micStream || !!window.micSource; 

  if (needAudio){
    audioCtx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
    const mediaDest = audioCtx.createMediaStreamDestination();

// Ensure micSource exists if user enabled the mic before recording
if (window.micStream && !window.micSource) {
  try {
    window.micSource = audioCtx.createMediaStreamSource(window.micStream);
  } catch (e) {
    console.warn('Could not create micSource:', e);
  }
}

// Mix mic into the recording graph
if (window.micSource) {
  try {
    window.micSource.connect(mediaDest);
  } catch (e) {
    console.warn('Could not connect micSource to mediaDest:', e);
  }
}

    if (!localAudioEl && localAudioList.length){
      localAudioEl = new Audio();
      localAudioEl.preload = 'auto';
      localAudioEl.src = localAudioList[0].url;
      localAudioEl.load();
    }

    if (localAudioEl){
      try{
        window._audioElNode = window._audioElNode || audioCtx.createMediaElementSource(localAudioEl);
        window._audioElNode.connect(mediaDest);            // to recording
        window._audioElNode.connect(audioCtx.destination); // monitor
      }catch(_){}
    }

    if (window.micSource){
      try{ micSource.connect(mediaDest); }catch(_){}
    }

    mixedStream = new MediaStream([
      ...canvasStream.getVideoTracks(),
      ...mediaDest.stream.getAudioTracks()
    ]);

    try{ if (audioCtx.state !== 'running') await audioCtx.resume(); }catch(_){}
    try{ if (localAudioEl){ localAudioEl.muted = false; await localAudioEl.play().catch(()=>{}); } }catch(_){}
    await new Promise(r => setTimeout(r, 120));
  }

  // 5) Build MediaRecorder (WebM only, best variant supported)
  const REC_MIME =
    (MediaRecorder.isTypeSupported?.('video/webm;codecs=vp9,opus') && 'video/webm;codecs=vp9,opus') ||
    (MediaRecorder.isTypeSupported?.('video/webm;codecs=vp8,opus') && 'video/webm;codecs=vp8,opus') ||
    'video/webm';

  let options = {
    mimeType: REC_MIME,
    videoBitsPerSecond: VBPS,
    audioBitsPerSecond: ABPS
  };

  recordedChunks = [];
  try { mediaRecorder = new MediaRecorder(mixedStream, options); }
  catch(e){ mediaRecorder = new MediaRecorder(mixedStream); }

  mediaRecorder.ondataavailable = e => { if (e.data && e.data.size > 0) recordedChunks.push(e.data); };
  mediaRecorder.onstop = () => {
    cancelAnimationFrame(recRAF);
    const outType = recordedChunks[0]?.type || 'video/webm';
    const blob = new Blob(recordedChunks, { type: outType });
    openRecSave(blob, tsName('webm')); // WebM only
  };

  // 6) Start recording (tiny delay avoids empty first chunk)
  setTimeout(() => mediaRecorder.start(100), 120);

  // 7) UI
  isRecording = true;
  recordBtn.classList.add('recording');
  recordBtn.textContent = 'Stop Recording';
  toast(`Recording ${w}×${h} | ${REC_FPS} fps started`);
}

function stopRecording(){
  if(!isRecording) return;

  // stop the recorder if it's still active
  try{
    if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop();
  }catch(_){}

  // fallback: ensure we’re not still drawing
  try{ if (recRAF) cancelAnimationFrame(recRAF); }catch(_){}

  isRecording = false;
  recordBtn.classList.remove('recording');
  recordBtn.textContent = 'Record Remix';

  // re-enable the resolution selector (if you disabled it on start)
  const sel = document.getElementById('recRes');
  if (sel) sel.disabled = false;

  // allow the preview canvas to follow window size again
  try{ resizeRecCanvas(); }catch(_){}

  try{ toast('Recording stopped'); }catch(_){}
}

    function openRecSave(blob, defName){
      recInput.value = defName;
      recOverlay.classList.add('active'); recModal.classList.add('active');
      const saver = ()=>{
        const name=(recInput.value.trim()||defName).replace(/[\/\\:*?"<>|]/g,'_');
        const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=name; document.body.appendChild(a); a.click(); a.remove();
        setTimeout(()=>URL.revokeObjectURL(url),1000);
        closeRecSave();
        toast('Saved as '+name);
      };
      recSave.onclick = saver;
    }
    function closeRecSave(){ recOverlay.classList.remove('active'); recModal.classList.remove('active'); }

    recOverlay.addEventListener('click', closeRecSave); recClose.addEventListener('click', closeRecSave);

  </script>

<script>
  // Keep slider fill (background-size) in sync with value
  (function(){
    const all = document.querySelectorAll('input[type="range"]');
    const sync = r => {
      const min = r.min ? +r.min : 0;
      const max = r.max ? +r.max : 100;
      const val = +r.value;
      const pct = ((val - min) / (max - min)) * 100;
      r.style.setProperty('--p', pct + '%');
    };
    all.forEach(r => { sync(r); r.addEventListener('input', ()=>sync(r)); r.addEventListener('change', ()=>sync(r)); });
  })();
</script>

<script>
document.querySelectorAll('input[type="range"]').forEach(r=>{
  const set = ()=> r.style.setProperty('--p', (100*(r.value - r.min)/(r.max - r.min)) + '%');
  ['input','change'].forEach(ev=> r.addEventListener(ev, set));
  set();
});
</script>

</body>
</html>
