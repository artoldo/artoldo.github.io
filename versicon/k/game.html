<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="robots" content="noindex, nofollow">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Kaltcaldo</title>
<style>
    body {
        background-color: #000;
        color: #00FFFF;
        font-family: 'Courier New', Courier, monospace;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        margin: 0;
        overflow: hidden;
    }
    #terminal {
        width: 80%;
        max-width: 600px;
        height: 90vh;
        background-color: transparent;
        backdrop-filter: blur(20px);
        padding: 20px;
        padding-bottom: 100px;
        border-radius: 10px;
        border: 2px solid #333;
        overflow-y: auto;
        box-sizing: border-box;
        scroll-behavior: auto;
    }
    #terminal:focus { outline: none; }
    #output { white-space: pre-wrap; margin-bottom: 10px; color: #FFFFFF; }
    #input-line { display: inline; }
    #user-input { color: #FFFFFF; }
    .command-color1, .command-color2, .command-color3 { color: #FFFFFF; }
    .folder { background-color: #fff; color: #000; padding:5px 10px; border-radius:3px; margin-top:8px; display:inline-block; }
    .file { background-color: #333; color: #FFF; padding:5px 10px; border-radius:3px; margin-top:8px; display:inline-block; }
    .cursor { animation: blink 1s steps(2, start) infinite; color:#FFFFFF; }
    @keyframes blink { 50% { opacity: 0; } }
    * { -webkit-user-select:none; -moz-user-select:none; -ms-user-select:none; user-select:none; }
    .input-prompt { color: #FFFFFF; }
</style>

<style>
html,body{margin:0;padding:0;background:#000;overflow:hidden;}
#bgCanvas{position:fixed;inset:0;margin:0;padding:0;z-index:-10;pointer-events:none;}
#bgCanvas canvas{position:fixed;top:0;left:0;width:100%;height:100%;display:block;filter:blur(1.5px);pointer-events:none;}
body, #container{position:relative;z-index:0;}
</style>
</head>
<body>

<div id="bgCanvas"><canvas id="mainCanvas"></canvas></div>

<div id="terminal" tabindex="0">
    <input type="text" id="hidden-input" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" style="position:absolute;top:8px;left:8px;width:1px;height:1px;opacity:0.01;pointer-events:auto;">
    <div id="output"></div>
    <div>
        <span id="input-line"><span class="input-prompt">&gt; </span></span><span id="user-input"></span><span class="cursor">_</span>
    </div>
</div>

<script>
// Particle background
(function(){
    const canvas = document.getElementById("mainCanvas");
    const ctx = canvas.getContext("2d");
    let width = window.innerWidth, height = window.innerHeight;
    canvas.width = width; canvas.height = height;

    class Particle {
        constructor(){
            this.x = Math.random()*width;
            this.y = Math.random()*height;
            this.radius = 2 + Math.random()*3;
            this.vx = (Math.random()-0.5)*1.5;
            this.vy = (Math.random()-0.5)*1.5;
            this.alpha = 0.3 + Math.random()*0.7;
        }
        update(){
            this.x += this.vx; this.y += this.vy;
            if(this.x<0||this.x>width) this.vx*=-1;
            if(this.y<0||this.y>height) this.vy*=-1;
        }
        draw(ctx){
            const grad = ctx.createRadialGradient(this.x,this.y,0,this.x,this.y,this.radius*4);
            grad.addColorStop(0, `rgba(255,0,0,${this.alpha})`);
            grad.addColorStop(1,'rgba(0,0,0,0)');
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(this.x,this.y,this.radius*4,0,Math.PI*2);
            ctx.fill();
            ctx.fillStyle = `rgba(255,255,255,${this.alpha})`;
            ctx.beginPath();
            ctx.arc(this.x,this.y,this.radius,0,Math.PI*2);
            ctx.fill();
        }
    }

    const NUM_PARTICLES = 120;
    const particles = Array.from({length: NUM_PARTICLES},()=>new Particle());

    function animate(){
        ctx.clearRect(0,0,width,height);
        for(let i=0;i<particles.length;i++){
            for(let j=i+1;j<particles.length;j++){
                const p1 = particles[i], p2 = particles[j];
                const dist = Math.hypot(p1.x-p2.x, p1.y-p2.y);
                if(dist<120){
                    ctx.strokeStyle = `rgba(0,255,255,${1-dist/120})`;
                    ctx.lineWidth = 0.8;
                    ctx.beginPath();
                    ctx.moveTo(p1.x,p1.y);
                    ctx.lineTo(p2.x,p2.y);
                    ctx.stroke();
                }
            }
        }
        particles.forEach(p=>{p.update(); p.draw(ctx);});
        requestAnimationFrame(animate);
    }
    animate();
    window.addEventListener("resize",()=>{width=window.innerWidth;height=window.innerHeight;canvas.width=width;canvas.height=height;});
})();
</script>

<script>
// Terminal logic (fixed from Earth 61250)
const outputDiv = document.getElementById('output');
const userInputSpan = document.getElementById('user-input');
const hiddenInput = document.getElementById('hidden-input');

const ROOT_DIR = 'root';
let currentDirectory = ROOT_DIR;
const fileSystem = {
    "root": { folders: ["experiments","simulations","formulas","archives","reports"], files: [] },
    "root/experiments": { folders: [], files: ["energy-flux.log","thermal-gradient.txt","entropy-measurements.txt","phase-transitions.log"] },
    "root/simulations": { folders: ["fluid_dynamics","heat_transfer","quantum_effects"], files: ["simulation-parameters.zip","results-summary.doc","runtime-config.doc"] },
    "root/simulations/quantum_effects": { folders: [], files: ["wave-function.doc","energy-states.txt","quantum-fluctuations.doc"] },
    "root/formulas": { folders: ["thermodynamics","statistical","quantum"], files: ["energy-conservation.doc","entropy-equations.conf","heat-capacity.txt"] },
    "root/archives": { folders: ["daily","monthly"], files: ["backup-thermo.zip"] },
    "root/reports": { folders: [], files: ["confidential-research.doc"] }
};

const fileContents = {
    "energy-flux.log":"Measured energy flux across the thermal boundary layer shows unexpected spikes at 350K.",
    "thermal-gradient.txt":"Temperature gradient data collected from recent experiments in controlled environments.",
    "entropy-measurements.txt":"Entropy values calculated for isolated systems during phase shifts.",
    "phase-transitions.log":"Recorded phase transitions with corresponding energy input and output.",
    "simulation-parameters.zip":{ type:"executable", action:shutdownSequence, snippet:"Executable file detected. Running 'thermo_secret.zip'..." },
    "results-summary.doc":"Summary of simulation results showing correlation between temperature and particle velocity.",
    "runtime-config.doc":"Configuration file for simulation runtime parameters and environment settings.",
    "wave-function.doc":"Detailed notes on wave function collapse in quantum thermodynamics.",
    "energy-states.txt":"List of possible energy states observed in recent quantum simulations.",
    "quantum-fluctuations.doc":"Documentation on observed quantum fluctuations affecting thermal equilibrium.",
    "energy-conservation.doc":"Fundamental equations governing energy conservation in closed systems.",
    "entropy-equations.conf":"Configuration and derivations of entropy-related formulas.",
    "heat-capacity.txt":"Experimental data on heat capacity under varying pressure and temperature.",
    "backup-thermo.zip":"Compressed archive of all critical thermodynamics research data.",
    "confidential-research.doc":"CONFIDENTIAL: Ongoing research summary. Access restricted."
};

function scrollTerminal() {
    const terminal = document.getElementById('terminal');
    requestAnimationFrame(() => {
        terminal.scrollTop = terminal.scrollHeight;
    });
}

function output(text){
    // Create a container div for the output line
    const lineDiv = document.createElement('div');
    lineDiv.innerHTML = `> ${text}`;
    outputDiv.appendChild(lineDiv);
    scrollTerminal();
}

function showDirectoryContents(){
    const folders = fileSystem[currentDirectory].folders.map(f=>`<span class="folder">${f}</span>`).join("  ");
    const files = fileSystem[currentDirectory].files.map(f=>`<span class="file">${f}</span>`).join("  ");
    output(`\nFolders:\n${folders || "None"}\n\nFiles:\n${files || "None"}`);
}

function shutdownSequence(){
    output(">>> Initiating classified thermodynamics data lockdown...");
    setTimeout(()=>{
        const terminal = document.getElementById("terminal");
        terminal.innerHTML = `
        <div style='color:#FFF; font-size:2em; text-align:center;'><br><br>Kaltcaldo</div>
        <p style='color:#FFF; font-size:1em; text-align:left; margin-top:10px;'>
        After decades of concealed research by the clandestine Quantum Thermodynamics Institute, the terminal finally reveals the Kaltcaldo Principle:
        <br><br>
        <strong>ΔS<sub>universe</sub> = ∫(δQ/T)<sub>ext</sub> + iħ∇·Ψ<sub>cold</sub></strong>
        <br><br>
        This formula is more than a mere extension of classical entropy—it integrates quantum coherence effects at cryogenic temperatures, allowing controlled manipulation of heat flow in near-absolute-zero environments. In layman's terms, Kaltcaldo unlocks the ability to reverse micro-scale entropy fluctuations without violating the second law, effectively opening pathways to ultra-efficient energy storage and quantum refrigeration.  
        <br><br>
        Researchers long feared this knowledge could destabilize conventional energy systems or trigger geopolitical conflicts over “cold tech” supremacy. The formula's digital imprint on this terminal is now the only remaining trace outside the vaults of the Quantum Thermodynamics Institute.  
        <br><br>
        Handle with extreme caution: what you do next could ripple through physics itself. <br><br><a href="https://artoldo.github.io/kaltcaldo/" style="text-decoration:underline; color: red;">E N T E R</a>
        </p>`;
        terminal.scrollTop = 0;
        document.removeEventListener('keydown', handleKeyDown);
    }, 4000);
}

function openFile(filename){
    const fileData = fileContents[filename];
    if(fileData){
        if(fileData.type==="executable") { output(fileData.snippet); fileData.action(); }
        else { output(fileData); }
    } else { output("<span class='command-color1'>File not found.</span>"); }
}

function processCommand(command){
    const target = command.trim();
    if(target==="back"){
        if(currentDirectory!==ROOT_DIR){
            currentDirectory = currentDirectory.split("/").slice(0,-1).join("/")||ROOT_DIR;
            output(`> You are now in ${currentDirectory}`);
            showDirectoryContents();
        } else output("<span class='command-color1'>Already at root.</span>");
    } else if(fileSystem[currentDirectory]?.folders.includes(target)){
        currentDirectory = `${currentDirectory}/${target}`;
        output(`> You entered ${currentDirectory}`);
        showDirectoryContents();
    } else if(fileSystem[currentDirectory]?.files.includes(target)){
        output(`> Opening file ${target}...`);
        openFile(target);
    } else output("<span class='command-color1'>Folder or file not found.</span>");
}

// Focus input on click
document.getElementById('terminal').addEventListener('click', () => {
    hiddenInput.focus();
});
window.onload = () => hiddenInput.focus();

// Reflect typed input
hiddenInput.addEventListener('input', () => {
    userInputSpan.innerText = hiddenInput.value;
});

// Handle Enter key for commands
hiddenInput.addEventListener('keydown', (event) => {
    if(event.key === 'Enter') {
        const command = hiddenInput.value;
        output(`<span class='command-color1'>${command}</span>`);
        processCommand(command);
        hiddenInput.value = '';
        userInputSpan.innerText = '';
    }
});

// Initial animation
function typingAnimation(text, callback){
    let index=0;
    function appendChar(){
        if(index < text.length){
            const span = document.createElement('span');
            span.style.color = '#FFF';
            span.textContent = text[index];
            outputDiv.appendChild(span);
            scrollTerminal();
            index++;
            setTimeout(appendChar, 100);
        } else {
            outputDiv.appendChild(document.createElement('br'));
            outputDiv.appendChild(document.createElement('br'));
            callback();
        }
    }
    appendChar();
}

typingAnimation("Accessing classified thermodynamics research... Explore directories to uncover secret formulas...", ()=>{
    output("Type the name of a <u>folder</u> or a <u>file</u> to open it.");
    output("Type <u>back</u> to return to the previous directory.");
    showDirectoryContents();
});

document.addEventListener('contextmenu', e=> e.preventDefault());
</script>

</body>
</html>