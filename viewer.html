<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="robots" content="noindex, nofollow">
  <title>Universal Metadata Viewer</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 2em auto;
      max-width: 900px;
      background: #f5f7fa;
      color: #333;
    }
    h1 {
      font-size: 2rem;
      margin-bottom: 0.5em;
      text-align: center;
      color: #2c3e50;
    }
    input[type="file"] {
      display: block;
      margin: 1em auto 2em;
      font-size: 1rem;
      cursor: pointer;
    }
    #preview {
      display: flex;
      justify-content: center;
      margin-bottom: 1em;
    }
    #preview img,
    #preview video {
      max-width: 300px;
      max-height: 200px;
      border-radius: 8px;
      box-shadow: 0 4px 10px rgb(0 0 0 / 0.1);
      object-fit: contain;
    }
    pre {
      background: #fff;
      border-radius: 8px;
      padding: 1em 1.5em;
      box-shadow: 0 0 10px rgb(0 0 0 / 0.1);
      white-space: pre-wrap;
      word-break: break-word;
      max-height: 400px;
      overflow-y: auto;
      font-family: 'Fira Mono', monospace;
      font-size: 0.9rem;
      line-height: 1.4;
    }
    .section-title {
      font-weight: 700;
      margin-top: 1.5em;
      margin-bottom: 0.3em;
      font-size: 1.1rem;
      color: #34495e;
      border-bottom: 2px solid #3498db;
      padding-bottom: 0.2em;
    }
    .note {
      font-size: 0.9em;
      color: #666;
      text-align: center;
      margin-top: 2em;
      font-style: italic;
    }
  </style>
</head>
<body>
  <h1>Universal Metadata Viewer</h1>
  <input type="file" id="fileInput" />
  <div id="preview"></div>
  <pre id="output">Choose a file to extract metadata...</pre>
  <div class="note">All processing is done locally in your browser. No files are uploaded.</div>

  <!-- Load music-metadata-browser as an ES module and attach to window.mm -->
  <script type="module">
    import * as musicMetadata from 'https://cdn.jsdelivr.net/npm/music-metadata-browser@2.7.9/dist/index.min.js';
    window.mm = musicMetadata;
  </script>

  <!-- Load EXIF library for image metadata -->
  <script src="https://cdn.jsdelivr.net/npm/exif-js"></script>

  <!-- Load MediaInfo.js dynamically -->
  <script>
    async function loadMediaInfo() {
      return new Promise((resolve, reject) => {
        if(window.MediaInfo) {
          resolve(window.MediaInfo({
            format: 'object',
            locateFile: (path) => `https://unpkg.com/mediainfo.js@0.1.8/dist/${path}`
          }));
          return;
        }
        const script = document.createElement('script');
        script.src = 'https://unpkg.com/mediainfo.js@0.1.8/dist/mediainfo.min.js';
        script.onload = async () => {
          try {
            const mi = await window.MediaInfo({
              format: 'object',
              locateFile: (path) => `https://unpkg.com/mediainfo.js@0.1.8/dist/${path}`,
            });
            resolve(mi);
          } catch (err) {
            reject(err);
          }
        };
        script.onerror = reject;
        document.head.appendChild(script);
      });
    }
  </script>

  <!-- Main Logic -->
  <script>
    const fileInput = document.getElementById('fileInput');
    const output = document.getElementById('output');
    const preview = document.getElementById('preview');

    fileInput.addEventListener('change', async (event) => {
      const file = event.target.files[0];
      if (!file) return;

      preview.innerHTML = '';
      output.textContent = `Reading metadata for: ${file.name}\n\n`;
      const type = file.type;

      try {
        if (type.startsWith('image/')) {
          await showImagePreview(file);
          await readImageMetadata(file);
        } else if (type.startsWith('audio/')) {
          await readMusicMetadata(file);
        } else if (type.startsWith('video/') || isLikelyVideo(file.name)) {
          await showVideoPreview(file);
          await readWithMediaInfo(file);
        } else {
          await readWithMediaInfo(file); // fallback for other types
        }
      } catch (err) {
        output.textContent += `\n‚ùå Error: ${err.message}`;
      }
    });

    function isLikelyVideo(filename) {
      return ['.mov', '.mp4', '.mkv', '.avi', '.webm'].some(ext => filename.toLowerCase().endsWith(ext));
    }

    async function showImagePreview(file) {
      return new Promise((resolve, reject) => {
        const url = URL.createObjectURL(file);
        const img = document.createElement('img');
        img.onload = () => {
          URL.revokeObjectURL(url);
          resolve();
        };
        img.onerror = reject;
        img.src = url;
        preview.appendChild(img);
      });
    }

    async function showVideoPreview(file) {
      return new Promise((resolve, reject) => {
        const url = URL.createObjectURL(file);
        const video = document.createElement('video');
        video.controls = true;
        video.width = 300;
        video.height = 200;
        video.onloadeddata = () => {
          URL.revokeObjectURL(url);
          resolve();
        };
        video.onerror = reject;
        video.src = url;
        preview.appendChild(video);
      });
    }

    async function readImageMetadata(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        const img = new Image();

        reader.onload = function (e) {
          img.onload = function () {
            EXIF.getData(img, function () {
              const data = EXIF.getAllTags(this);
              if (Object.keys(data).length === 0) {
                output.textContent += "üì∑ No EXIF metadata found.\n";
              } else {
                output.textContent += 'üì∑ Image Metadata:\n' + JSON.stringify(data, null, 2) + '\n';
              }
              resolve();
            });
          };
          img.src = e.target.result;
        };

        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }

async function readMusicMetadata(file) {
  const timeout = (ms) => new Promise((_, reject) => setTimeout(() => reject(new Error('Timed out after 10s')), ms));
  try {
    while (typeof window.mm === 'undefined') {
      await new Promise(r => setTimeout(r, 50));
    }

    const blob = file.slice(0, file.size); // full blob
    const metadata = await Promise.race([
      window.mm.parseBlob(blob),
      timeout(10000)
    ]);

    if (!metadata || (!metadata.common && !metadata.format)) {
      output.textContent += '‚ö†Ô∏è No readable metadata found in this audio file.\n';
      return;
    }

    const { format } = metadata;

    // Prepare summary values
    const duration = format.duration
      ? `${Math.floor(format.duration / 60)}:${String(Math.floor(format.duration % 60)).padStart(2, '0')}`
      : 'Unknown';

    const bitrate = format.bitrate
      ? `${(format.bitrate / 1000).toFixed(0)} kbps`
      : 'Unknown';

    const channels = format.numberOfChannels
      ? (format.numberOfChannels === 1 ? 'Mono' :
         format.numberOfChannels === 2 ? 'Stereo' :
         `${format.numberOfChannels} channels`)
      : 'Unknown';

    output.textContent += `üéµ Audio Summary:
‚è± Duration: ${duration}
üîà Channels: ${channels}
üéö Bitrate: ${bitrate}

`;

    if (metadata.common) {
      output.textContent += 'üìù Common Tags:\n' +
        JSON.stringify(metadata.common, null, 2) + '\n';
    }

    if (format) {
      output.textContent += '‚öôÔ∏è Technical Metadata:\n' +
        JSON.stringify(format, null, 2) + '\n';
    }

  } catch (err) {
    output.textContent += `‚ùå Audio metadata error: ${err.message}\n`;
  }
}

    async function readWithMediaInfo(file) {
      try {
        const mediaInfo = await loadMediaInfo();
        const getSize = () => file.size;
        const readChunk = (chunkSize, offset) =>
          new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = e => resolve(new Uint8Array(e.target.result));
            reader.onerror = reject;
            reader.readAsArrayBuffer(file.slice(offset, offset + chunkSize));
          });

        const result = await mediaInfo.analyzeData(getSize, readChunk);
        if (!result || !result.media) {
          output.textContent += 'üì¶ No metadata found by MediaInfo.\n';
          return;
        }

        // Output general metadata (if any)
        if(result.media.track && result.media.track.length > 0){
          output.textContent += 'üì¶ MediaInfo Metadata:\n';

          // Group tracks by type for clarity
          const tracksByType = result.media.track.reduce((acc, t) => {
            const type = t['@type'] || 'Unknown';
            if (!acc[type]) acc[type] = [];
            acc[type].push(t);
            return acc;
          }, {});

          for(const [type, tracks] of Object.entries(tracksByType)) {
            output.textContent += `\n--- ${type} Track(s) ---\n`;
            tracks.forEach((track, idx) => {
              output.textContent += `Track ${idx + 1}:\n${JSON.stringify(track, null, 2)}\n\n`;
            });
          }
        } else {
          output.textContent += JSON.stringify(result.media, null, 2);
        }

      } catch (err) {
        output.textContent += `‚ùå MediaInfo error: ${err.message}\n`;
      }
    }
  </script>
</body>
</html>