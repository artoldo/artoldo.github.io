<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="robots" content="noindex, nofollow">
  <title>Universal Metadata Viewer</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 2em auto;
      max-width: 900px;
      background: #f5f7fa;
      color: #333;
    }
    h1 {
      font-size: 2rem;
      text-align: center;
      color: #2c3e50;
    }
    input[type="file"] {
      display: block;
      margin: 1em auto 2em;
    }
    #preview {
      display: flex;
      justify-content: center;
      margin-bottom: 1em;
    }
    #preview img, #preview video {
      max-width: 300px;
      max-height: 200px;
      border-radius: 8px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    }
    pre {
      background: #fff;
      padding: 1em;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
      white-space: pre-wrap;
      overflow-y: auto;
    }
    details {
      margin-top: 1em;
    }
    .note {
      text-align: center;
      font-style: italic;
      color: #666;
    }
  </style>
</head>
<body>
  <h1>Universal Metadata Viewer</h1>
  <input type="file" id="fileInput" />
  <div id="preview"></div>
  <pre id="output">Choose a file to extract metadata...</pre>
  <div class="note">All processing is done locally in your browser. No files are uploaded.</div>

  <script type="module">
    import * as musicMetadata from 'https://cdn.jsdelivr.net/npm/music-metadata-browser@2.7.9/dist/index.min.js';
    window.mm = musicMetadata;
  </script>
  <script src="https://cdn.jsdelivr.net/npm/exif-js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jsmediatags@3.9.7/dist/jsmediatags.min.js"></script>

  <script>
    async function loadMediaInfo() {
      if (window.MediaInfoLib) return window.MediaInfoLib;
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = 'https://unpkg.com/mediainfo.js@0.1.8/dist/mediainfo.min.js';
        script.onload = async () => {
          const mediaInfo = await window.MediaInfo({
            format: 'object',
            locateFile: path => `https://unpkg.com/mediainfo.js@0.1.8/dist/${path}`
          });
          window.MediaInfoLib = mediaInfo;
          resolve(mediaInfo);
        };
        script.onerror = reject;
        document.head.appendChild(script);
      });
    }

    const fileInput = document.getElementById('fileInput');
    const output = document.getElementById('output');
    const preview = document.getElementById('preview');

    fileInput.addEventListener('change', async (event) => {
      const file = event.target.files[0];
      if (!file) return;
      preview.innerHTML = '';
      output.innerHTML = `<p>Reading metadata for: <b>${file.name}</b></p>`;
      const type = file.type;

      try {
        if (type.startsWith('image/')) {
          await showImagePreview(file);
          await readImageMetadata(file);
        } else if (type.startsWith('audio/')) {
          await readBasicAudioInfo(file);
          await readWithMediaInfo(file, true);
          if (file.name.toLowerCase().endsWith('.mp3')) {
            readMP3TagsWithJsMediaTags(file);
          }
        } else if (type.startsWith('video/')) {
          await showVideoPreview(file);
          await readWithMediaInfo(file, false);
        } else {
          await readWithMediaInfo(file, false);
        }
      } catch (err) {
        // hide audio errors silently
        if (!type.startsWith('audio/')) {
          output.innerHTML += `<p>‚ùå Error: ${err.message}</p>`;
        }
      }
    });

    async function showImagePreview(file) {
      return new Promise((resolve, reject) => {
        const url = URL.createObjectURL(file);
        const img = new Image();
        img.onload = () => { URL.revokeObjectURL(url); resolve(); };
        img.onerror = reject;
        img.src = url;
        preview.appendChild(img);
      });
    }

    async function showVideoPreview(file) {
      const url = URL.createObjectURL(file);
      const video = document.createElement('video');
      video.controls = true;
      video.src = url;
      preview.appendChild(video);
    }

    async function readImageMetadata(file) {
      const reader = new FileReader();
      reader.onload = e => {
        const img = new Image();
        img.onload = () => {
          EXIF.getData(img, function () {
            const data = EXIF.getAllTags(this);
            output.innerHTML += `
              <hr>
              <details open>
                <summary>üì∑ Image EXIF Metadata</summary>
                <pre>${JSON.stringify(data, null, 2)}</pre>
              </details>`;
          });
        };
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    }

    // --- UPDATED to add bitrate and channels for basic audio ---
    async function readBasicAudioInfo(file) {
      return new Promise((resolve, reject) => {
        const audio = new Audio();
        audio.preload = 'metadata';

        audio.onloadedmetadata = () => {
          // Channels: We can try to detect mono/stereo from audio channel count if available,
          // but HTML Audio API doesn't expose channel info directly.
          // So we leave that info to MediaInfo.
          output.innerHTML += `
            <hr>
            <details open>
              <summary>üìª Basic Audio Info</summary>
              <ul>
                <li>‚è± Duration: ${audio.duration.toFixed(2)}s</li>
              </ul>
            </details>
          `;
          resolve();
        };

        audio.onerror = () => {
          // Hide errors silently for audio as requested
          resolve();
        };

        audio.src = URL.createObjectURL(file);
      });
    }

    function readMP3TagsWithJsMediaTags(file) {
      jsmediatags.read(file, {
        onSuccess: function(tag) {
          output.innerHTML += `
            <hr>
            <details open>
              <summary>üìù ID3 Tags (jsmediatags)</summary>
              <pre>${JSON.stringify(tag.tags, null, 2)}</pre>
            </details>`;
          if (tag.tags.picture) {
            const { data, format } = tag.tags.picture;
            const byteArray = new Uint8Array(data);
            const blob = new Blob([byteArray], { type: format });
            const url = URL.createObjectURL(blob);
            preview.innerHTML += `<img src="${url}" alt="Cover Art" style="max-width:200px; margin-top:1em;">`;
          }
        },
        onError: function(error) {
          // Silently ignore jsmediatags errors
        }
      });
    }

    // --- UPDATED to add bitrate and channels info inside MediaInfo output ---
    async function readWithMediaInfo(file, isAudio) {
      const mediaInfo = await loadMediaInfo();
      const getSize = () => file.size;
      const readChunk = (chunkSize, offset) =>
        new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = e => resolve(new Uint8Array(e.target.result));
          reader.onerror = reject;
          reader.readAsArrayBuffer(file.slice(offset, offset + chunkSize));
        });

      const result = await mediaInfo.analyzeData(getSize, readChunk);
      if (!result || !result.media || !result.media.track) {
        output.innerHTML += '<p>üì¶ No metadata found by MediaInfo.</p>';
        return;
      }

      const grouped = result.media.track.reduce((acc, track) => {
        const type = track["@type"] || "Unknown";
        acc[type] = acc[type] || [];
        acc[type].push(track);
        return acc;
      }, {});

      for (const [type, tracks] of Object.entries(grouped)) {
        // For audio/video, extract bitrate & channels summary if available
        let summary = '';
        if (type === 'Audio' || type === 'Video') {
          tracks.forEach((track, idx) => {
            const bitrate = track.BitRate || track.BitRate_Mode || track.BitRate_String || track['Bit rate'];
            // BitRate can be a string or number, ensure string with kbps unit
            let bitrateStr = '';
            if (bitrate) {
              if (typeof bitrate === 'number') {
                bitrateStr = `${(bitrate / 1000).toFixed(0)} kbps`;
              } else if (typeof bitrate === 'string') {
                bitrateStr = bitrate.includes('kb/s') || bitrate.includes('kbps') ? bitrate : bitrate + ' kbps';
              }
            }

            // Channels: use 'Channel(s)' or 'Channel(s)_Original' or 'Channels'
            const channelsRaw = track.Channels || track['Channel(s)'] || track['Channel(s)_Original'] || track.Channels_Original;
            let channelsStr = '';
            if (channelsRaw) {
              if (typeof channelsRaw === 'number') {
                channelsStr = channelsRaw === 1 ? 'Mono' : (channelsRaw === 2 ? 'Stereo' : `${channelsRaw} channels`);
              } else {
                channelsStr = channelsRaw;
              }
            }

            summary += `<li>Track ${idx + 1}: Bitrate: ${bitrateStr || 'N/A'}, Channels: ${channelsStr || 'N/A'}</li>`;
          });
          summary = `<ul>${summary}</ul>`;
        }

        output.innerHTML += `
          <hr>
          <details open>
            <summary>üìÅ ${type} Tracks (${tracks.length})</summary>
            ${summary}
            <pre>${JSON.stringify(tracks, null, 2)}</pre>
          </details>`;
      }
    }
  </script>
</body>
</html>